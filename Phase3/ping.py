# -*- generated by 1.0.9 -*-
import da
PatternExpr_581 = da.pat.TuplePattern([da.pat.ConstantPattern('requestConfiguration')])
PatternExpr_586 = da.pat.FreePattern('p')
PatternExpr_605 = da.pat.TuplePattern([da.pat.ConstantPattern('getGlobalData'), da.pat.FreePattern('key'), da.pat.FreePattern('ranDomID')])
PatternExpr_614 = da.pat.FreePattern('c')
PatternExpr_662 = da.pat.TuplePattern([da.pat.ConstantPattern('headOperation'), da.pat.FreePattern('clientId'), da.pat.FreePattern('requestID'), da.pat.FreePattern('slot'), da.pat.FreePattern('signedRequestStatement')])
PatternExpr_675 = da.pat.FreePattern('r')
PatternExpr_1578 = da.pat.TuplePattern([da.pat.FreePattern('Configuration')])
PatternExpr_1583 = da.pat.FreePattern('p')
PatternExpr_1643 = da.pat.TuplePattern([da.pat.ConstantPattern('result'), da.pat.FreePattern('resultShuttle')])
PatternExpr_1701 = da.pat.TuplePattern([da.pat.ConstantPattern('result'), da.pat.FreePattern('resultShuttle')])
PatternExpr_1708 = da.pat.FreePattern('tail')
PatternExpr_1846 = da.pat.TuplePattern([da.pat.ConstantPattern('dictionaryData'), da.pat.FreePattern('globalResult'), da.pat.FreePattern('randID')])
PatternExpr_2872 = da.pat.TuplePattern([da.pat.ConstantPattern('initial'), da.pat.FreePattern('messageNumber'), da.pat.FreePattern('clientId'), da.pat.FreePattern('requestID'), da.pat.FreePattern('signedRequestStatement'), da.pat.FreePattern('operationCount')])
PatternExpr_2887 = da.pat.FreePattern('c')
PatternExpr_3244 = da.pat.TuplePattern([da.pat.FreePattern('messageNumber'), da.pat.FreePattern('clientId'), da.pat.FreePattern('requestID'), da.pat.FreePattern('tempSlot'), da.pat.FreePattern('signedRequestStatement'), da.pat.FreePattern('shuttle'), da.pat.FreePattern('typeOfRequest'), da.pat.FreePattern('replicaType'), da.pat.FreePattern('operationCount'), da.pat.FreePattern('shuttleNumber')])
PatternExpr_3266 = da.pat.FreePattern('previousReplica')
PatternExpr_3755 = da.pat.TuplePattern([da.pat.ConstantPattern('retransmission'), da.pat.FreePattern('messageNumber'), da.pat.FreePattern('clientId'), da.pat.FreePattern('requestID'), da.pat.FreePattern('signedRequestStatement')])
PatternExpr_3768 = da.pat.FreePattern('c')
PatternExpr_3910 = da.pat.TuplePattern([da.pat.FreePattern('result'), da.pat.FreePattern('resultShuttle')])
PatternExpr_3983 = da.pat.TuplePattern([da.pat.ConstantPattern('forwardRequest'), da.pat.FreePattern('clientId'), da.pat.FreePattern('requestID'), da.pat.FreePattern('signedRequestStatement')])
PatternExpr_3994 = da.pat.FreePattern('p')
PatternExpr_4089 = da.pat.TuplePattern([da.pat.FreePattern('result'), da.pat.FreePattern('resultShuttle')])
PatternExpr_4581 = da.pat.TuplePattern([da.pat.ConstantPattern('result'), da.pat.FreePattern('resultShuttle'), da.pat.FreePattern('resultShuttleNumber'), da.pat.FreePattern('clientId')])
PatternExpr_4591 = da.pat.FreePattern('nextReplica')
_config_object = {}
import sys
import nacl.utils
from random import *
import random
import nacl.encoding
import nacl.hash
from nacl.bindings.utils import sodium_memcmp
import nacl.signing
import logging

def readConfigFile():
    config = dict()
    with open('config.csv', 'r') as f:
        for line in f:
            if (not (line[0] == '#')):
                (key, sep, val) = line.partition('=')
                if (not (len(sep) == 0)):
                    val = val.strip()
                    config[key.strip()] = (int(val) if str.isdecimal(val) else val)
    return config

def signTheStatement(signing_key, message):
    return signing_key.sign(message)
    self.output('-------------Signed the message---------------------------')

def decodeVerifyKey(verify_key_hex):
    return nacl.signing.VerifyKey(verify_key_hex, encoder=nacl.encoding.HexEncoder)

def verifyTheStatement(verify_key, signed):
    return verify_key.verify(signed)

class Utils():

    def helloClass(self):
        return 'Hello Class'

    def signTheStatement(self, signing_key, message):
        return signing_key.sign(message)

    def decodeVerifyKey(self, verify_key_hex):
        return nacl.signing.VerifyKey(verify_key_hex, encoder=nacl.encoding.HexEncoder)

    def verifyTheStatement(self, verify_key, signed):
        return verify_key.verify(signed)

    def hashResult(self, r):
        HASHER = nacl.hash.sha256
        digest = HASHER(bytes(r, 'utf-8'), encoder=nacl.encoding.HexEncoder)
        encodedMessage = nacl.encoding.HexEncoder.encode(bytes(r, 'utf-8'))
        return (digest.decode('utf-8'), encodedMessage.decode('utf-8'))

    def checkHashResult(self, digest, rDigest):
        bDigest = bytes(digest, 'utf-8')
        brDigest = bytes(rDigest, 'utf-8')
        if sodium_memcmp(bDigest, brDigest):
            return True
        return False

    def parseTheUnsignedStatement(self, unSignedRequestStatement):
        inp = str(unSignedRequestStatement, 'utf-8')
        inp = inp.split(')')[0]
        opKeyVal = inp.split('(')
        operation = opKeyVal[0]
        keyVal = opKeyVal[1].split(',')
        key = keyVal[0][1:(- 1)]
        value = ''
        if (not (operation == 'get')):
            value = keyVal[1][1:(- 1)]
        return (operation, key, value.strip())

class Olympus(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_0', PatternExpr_581, sources=[PatternExpr_586], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_580]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_1', PatternExpr_605, sources=[PatternExpr_614], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_604]), da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_2', PatternExpr_662, sources=[PatternExpr_675], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_661])])

    def setup(self, **rest_5707):
        super().setup(**rest_5707)
        self.output('--------------- ENTERING Olymus:setup ---------------', level=20)
        self.output(self._id)
        self._state.utilities = Utils()
        self._state.terminate = False
        self._state.client_signing_keys = dict()
        self._state.client_verify_keys_hex = dict()
        self._state.replica_signing_keys = dict()
        self._state.replica_verify_keys_hex = dict()
        self._state.globalData = dict()
        self.initialSetup()

    def run(self):
        super()._label('_st_label_574', block=False)
        _st_label_574 = 0
        while (_st_label_574 == 0):
            _st_label_574 += 1
            if self._state.terminate:
                _st_label_574 += 1
            else:
                super()._label('_st_label_574', block=True)
                _st_label_574 -= 1
        self.output('terminating')

    def updateOwnDictionary(self, requestStatement):
        self.output('--------------- Olymus:headOperation:updateOwnDictionary ---------------', level=20)
        (operation, key, value) = self._state.utilities.parseTheUnsignedStatement(requestStatement)
        self.output('---------------operation,key,value ---------------------', operation, key, value, level=10)
        result = self.executeOperation(operation, key, value)
        self.output('---------------result---------------------', result, level=10)

    def readGlobalConfigFile(self):
        self.output('--------------- ENTERING Olymus:initialSetup:readGlobalConfigFile ---------------', level=20)
        self._state.globalConfig = readConfigFile()

    def initialSetup(self):
        self.output('--------------- ENTERING Olymus:initialSetup ---------------', level=20)
        self._state.globalConfig = readConfigFile()
        noOfClients = self._state.globalConfig['num_client']
        noOfReplicas = ((2 * self._state.globalConfig['t']) + 1)
        (self._state.client_signing_keys, self._state.client_verify_keys_hex) = self.createKeys(noOfClients)
        self._state.clients = self.createClientProcesses(self._state.client_signing_keys)
        (self._state.replica_signing_keys, self._state.replica_verify_keys_hex) = self.createKeys(noOfReplicas)
        self._state.replicas = self.createReplicaProcesses(self._state.replica_signing_keys, self._state.clients, self._state.replica_verify_keys_hex)

    def createKeys(self, number):
        self.output('--------------- ENTERING Olymus:initialSetup:createKeys for clients and replicas---------------', level=20)
        signing_keys = dict()
        verify_keys_hex = dict()
        for i in range(number):
            signing_key = nacl.signing.SigningKey.generate()
            verify_key = signing_key.verify_key
            verify_key_hex = verify_key.encode(encoder=nacl.encoding.HexEncoder)
            signing_keys[i] = signing_key
            verify_keys_hex[i] = verify_key_hex
        return (signing_keys, verify_keys_hex)

    def createClientProcesses(self, client_signing_keys):
        tempClients = []
        self.output('--------------- ENTERING Olymus:initialSetup:createClientProcesses---------------', level=20)
        noOfClients = self._state.globalConfig['num_client']
        hosts = self._state.globalConfig['hosts'].split(';')
        client_hosts = self._state.globalConfig['client_hosts'].split(';')
        for i in range(noOfClients):
            processAtNode = ('Client' + str(i))
            client = self.new(Client, at=processAtNode)
            self._setup(client, (self._id, i, client_signing_keys[i]))
            self._start(client)
            tempClients.insert(i, (client, self._state.client_verify_keys_hex[i]))
        return tempClients

    def createReplicaProcesses(self, replica_signing_keys, clients, replica_verify_keys_hex):
        self.output('--------------- ENTERING Olymus:initialSetup:createReplicaProcesses---------------', level=20)
        tempReplicas = dict()
        noOfReplicas = ((2 * self._state.globalConfig['t']) + 1)
        hosts = self._state.globalConfig['hosts'].split(';')
        replica_hosts = self._state.globalConfig['replica_hosts'].split(';')
        for i in range(noOfReplicas):
            processAtNode = ('Replica' + str(i))
            replica = self.new(Replica, at=processAtNode)
            tempReplicas[i] = (replica, replica_verify_keys_hex[i])
        for i in range(noOfReplicas):
            self._setup(tempReplicas[i][0], (self._id, i, 'ACTIVE', replica_signing_keys[i], clients, tempReplicas))
            self._start(tempReplicas[i][0])
        return tempReplicas

    def parseTheUnsignedStatement(self, unSignedRequestStatement):
        self.output('--------------- parseTheUnsignedStatement ---------------', level=20)
        inp = str(unSignedRequestStatement, 'utf-8')
        inp = inp.split(')')[0]
        self.output(inp, level=10)
        opKeyVal = inp.split('(')
        operation = opKeyVal[0]
        keyVal = opKeyVal[1].split(',')
        key = keyVal[0][1:(- 1)]
        value = ''
        if (not (operation == 'get')):
            value = keyVal[1][1:(- 1)]
        return (operation, key, value.strip())

    def addToDictionary(self, key, val):
        try:
            self._state.globalData[key] = ['OK', val]
            return 'OK'
        except:
            self._state.globalData[key] = ['fail', val]
            return 'Fail'

    def getFrom(self, key, val):
        try:
            getVal = self._state.globalData[key][1]
            if ((not (getVal == 'fail')) and (not (getVal == '')) and (not (getVal is None))):
                self._state.globalData[key] = ['', getVal, '']
            else:
                self._state.globalData[key] = ['', '']
            return self._state.globalData[key]
        except:
            self._state.globalData[key] = ['', 'fail']
            return ''

    def appendDictionary(self, key, val):
        try:
            valueExsist = self._state.globalData[key][1]
            if ((not (valueExsist == 'fail')) and (not (valueExsist == '')) and (not (valueExsist is None))):
                self.output('------valueExist-----', valueExsist, level=10)
                newVal = (valueExsist + val)
                self.output('------newVal-----', newVal, level=10)
                self._state.globalData[key] = ['OK', newVal]
            else:
                self._state.globalData[key] = ['fail', 'fail']
            return 'OK'
        except:
            self._state.globalData[key] = ['fail', 'fail']
            return 'fail'

    def sliceDictionary(self, key, val):
        try:
            value = self._state.globalData[key][1]
            if ((not (value == 'fail')) and (not (value == '')) and (not (value == ' ')) and (not (value is None))):
                indices = val.split(':')
                self._state.globalData[key] = ['OK', value[int(indices[0]):int(indices[1])]]
            else:
                self._state.globalData[key] = ['fail', 'fail']
            return 'OK'
        except:
            self._state.globalData[key] = ['fail', '']
            return 'fail'

    def executeOperation(self, operation, key, val):
        self.output('--------------- Olymus:headOperation:executeOperation ---------------', operation, key, val, level=20)
        function_launch = {'put': self.addToDictionary, 'get': self.getFrom, 'append': self.appendDictionary, 'slice': self.sliceDictionary}
        return function_launch[operation](key, val)

    def _Olympus_handler_580(self, p):
        self.output('--------------- ENTERING olympus:receieve:requestConfiguration ---------------', level=20)
        self.output(p)
        Configuration = self._state.replicas
        self.send((Configuration,), to=p)
    _Olympus_handler_580._labels = None
    _Olympus_handler_580._notlabels = None

    def _Olympus_handler_604(self, key, ranDomID, c):
        self.output('--------------- ENTERING Olymus:getGlobalData for key ---------------', key, level=20)
        self.output('---------------globalData ---------------------', self._state.globalData, level=10)
        globalVal = []
        self.output('---------------Dict content--------------------', self._state.globalData[key], level=10)
        try:
            globalVal = self._state.globalData[key]
        except:
            globalVal = None
        self.output('---------------globalVal ---------------------', globalVal, level=10)
        self.output('--------------- Sending globaData to client ---------------', globalVal, level=20)
        self.send(('dictionaryData', globalVal, ranDomID), to=c)
    _Olympus_handler_604._labels = None
    _Olympus_handler_604._notlabels = None

    def _Olympus_handler_661(self, clientId, requestID, slot, signedRequestStatement, r):
        self.output('--------------- ENTERING Olymus:receives operation from head for client ---------------', clientId, level=20)
        temp_verify_key = self._state.utilities.decodeVerifyKey(self._state.client_verify_keys_hex[clientId])
        verified = ''
        try:
            verified = self._state.utilities.verifyTheStatement(temp_verify_key, signedRequestStatement)
        except:
            verified = 'Not verified'
        self.output('---------------verified ---------------------', verified, level=10)
        self.output('---------------globalData ---------------------', self._state.globalData, level=10)
        self.updateOwnDictionary(verified)
    _Olympus_handler_661._labels = None
    _Olympus_handler_661._notlabels = None

class Client(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ClientReceivedEvent_1 = []
        self._ClientReceivedEvent_3 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_0', PatternExpr_1578, sources=[PatternExpr_1583], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1577]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_1', PatternExpr_1643, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_2', PatternExpr_1701, sources=[PatternExpr_1708], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1700]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_3', PatternExpr_1846, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, p, clientID, client_signing_key, **rest_5707):
        super().setup(p=p, clientID=clientID, client_signing_key=client_signing_key, **rest_5707)
        self._state.p = p
        self._state.clientID = clientID
        self._state.client_signing_key = client_signing_key
        self._state.terminate = False
        self._state.utilities = Utils()
        self._state.replicas = dict()
        self._state.TIMEOUT = 0
        self._state.globalConfig = dict()
        self._state.noOfReplicas = 0
        self._state.data = dict()

    def run(self):
        self.output('--------------- ENTERING Client:run ---------------', level=20)
        self.output('--------------- Requesting Configuration from Olympus---------------', level=20)
        self.send(('requestConfiguration',), to=self._state.p)
        self._state.globalConfig = readConfigFile()
        self._state.TIMEOUT = self._state.globalConfig['client_timeout']
        self._state.noOfReplicas = ((2 * self._state.globalConfig['t']) + 1)
        super()._label('_st_label_1496', block=False)
        _st_label_1496 = 0
        while (_st_label_1496 == 0):
            _st_label_1496 += 1
            if self._state.terminate:
                _st_label_1496 += 1
            else:
                super()._label('_st_label_1496', block=True)
                _st_label_1496 -= 1

    def hashResult(self, r):
        self.output('--------------- Creating hash digest for result ---------------', level=20)
        HASHER = nacl.hash.sha256
        digest = HASHER(bytes(r, 'utf-8'), encoder=nacl.encoding.HexEncoder)
        encodedMessage = nacl.encoding.HexEncoder.encode(bytes(r, 'utf-8'))
        return (digest.decode('utf-8'), encodedMessage.decode('utf-8'))

    def checkHashResult(self, digest, rDigest):
        self.output('--------------- Checking hash digests for results ---------------', level=20)
        bDigest = bytes(digest, 'utf-8')
        brDigest = bytes(rDigest, 'utf-8')
        if sodium_memcmp(bDigest, brDigest):
            return True
        return False

    def checkExpectedResult(self, reqID):
        self.output('--------------- Checking result against expected result --------------', level=20)
        (res, val, key) = self._state.data[reqID]
        self.output('--------------- Result in Client Dictionary: --------------', res, level=20)
        globalVal = ''
        ranDomID = self.returnRandomNumber()
        self.output('--------------- Get Data in global dictionary from olympus for Key: % with ID --------------', key, ranDomID, level=20)
        self.send(('getGlobalData', key, ranDomID), to=self._state.p)
        globalRes = ''
        globalResult = ''
        super()._label('_st_label_1843', block=False)
        globalResult = randID = None

        def ExistentialOpExpr_1844():
            nonlocal globalResult, randID
            for (_, _, (_ConstantPattern1862_, globalResult, randID)) in self._ClientReceivedEvent_3:
                if (_ConstantPattern1862_ == 'dictionaryData'):
                    if (randID == ranDomID):
                        return True
            return False
        _st_label_1843 = 0
        while (_st_label_1843 == 0):
            _st_label_1843 += 1
            if ExistentialOpExpr_1844():
                self.output('--------------- Received Data from global dictionary: % for key: % --------------', globalResult, key, level=20)
                globalRes = globalResult
                _st_label_1843 += 1
            else:
                super()._label('_st_label_1843', block=True)
                _st_label_1843 -= 1
        return (res, globalRes)

    def getOperations(self):
        self.output('--------------- Generating Workload for client --------------', level=20)
        cWorkLoad = self._state.globalConfig[(('workload[' + str(self._state.clientID)) + ']')]
        if ('pseudorandom' in cWorkLoad):
            seedAndNoOfRequests = cWorkLoad[:(- 1)].split('(')[1].split(',')
            return self.generatePseudoRandomRequests(int(seedAndNoOfRequests[0]), int(seedAndNoOfRequests[1]))
        else:
            return cWorkLoad.split(';')

    def sendRequest(self, messageNumber, requestID, operation, receiver, typeOfRequest):
        requestStatement = bytes(str(operation.strip()), 'utf8')
        self.output('--------------- Signing the request statement: --------------', requestStatement, level=20)
        signedRequestStatement = self._state.utilities.signTheStatement(self._state.client_signing_key, requestStatement)
        if (typeOfRequest == 'initial'):
            self.output('--------------- Sending request to head --------------', level=20)
            self.send((typeOfRequest, messageNumber, self._state.clientID, requestID, signedRequestStatement, 1), to=receiver[0])
            self.updateOwnDictionary(requestID, operation)
        elif (typeOfRequest == 'retransmission'):
            for replicaNo in range(self._state.noOfReplicas):
                self.output('--------------- Sending Retransmission request to all replicas --------------', level=20)
                self.send((typeOfRequest, messageNumber, self._state.clientID, requestID, signedRequestStatement), to=receiver[replicaNo][0])

    def updateOwnDictionary(self, requestID, op):
        (operation, key, value) = self._state.utilities.parseTheUnsignedStatement(bytes(str(op.strip()), 'utf8'))
        self.output('--------------- Client updates its dictionary with: --------------', operation, key, value, level=20)
        result = self.executeOperation(operation, requestID, value, key)
        self.output('--------------- Result upon updating dictionary: --------------', result, level=20)

    def generatePseudoRandomRequests(self, rSeed, noOfRequests):
        self.output('--------------- Generating Pseudo Random Requests for Client --------------', level=20)
        listofRequest = ["put('movie','star')", "append('movie',' wars')", "get('movie')", "put('jedi','luke skywalker')", "slice('jedi','0:4')", "get('jedi')"]
        random.seed(rSeed)
        requests = random.sample(listofRequest, k=noOfRequests)
        return requests

    def returnRandomNumber(self):
        return randint(1, 10000)

    def verifyResultProofs(self, tempResultProof, rDigest):
        self.output('--------------- Verifying result and signature of result statements --------------', level=20)
        numOfRP = len(tempResultProof)
        i = 0
        verified = ''
        countOfCorrectResults = 0
        while (i < numOfRP):
            temp_verify_key = self._state.utilities.decodeVerifyKey(self._state.replicas[i][1])
            tempSignedRP = tempResultProof[i]
            try:
                verified = self._state.utilities.verifyTheStatement(temp_verify_key, tempSignedRP)
                strVerified = verified.decode('utf8')
                verifiedTuple = strVerified.split(';')
                if self._state.utilities.checkHashResult(verifiedTuple[2], rDigest):
                    verified = 'True'
                    countOfCorrectResults += 1
                else:
                    verified = 'False'
            except:
                verified = 'False'
            i += 1
            quorumSize = (self._state.globalConfig['t'] + 1)
            self.output('---------------Quorum Size--------------', quorumSize, level=20)
            self.output('---------------No. of countOfCorrectResults--------------', countOfCorrectResults, level=20)
            if (countOfCorrectResults >= quorumSize):
                verified = 'True'
            else:
                verified = 'False'
        return verified

    def parseTheUnsignedStatement(self, unSignedRequestStatement):
        self.output('--------------- Parsing the unsigned statement --------------', level=20)
        inp = str(unSignedRequestStatement, 'utf-8')
        inp = inp.split(')')[0]
        self.output(inp, level=10)
        opKeyVal = inp.split('(')
        operation = opKeyVal[0]
        keyVal = opKeyVal[1].split(',')
        key = keyVal[0][1:(- 1)]
        value = ''
        if (not (operation == 'get')):
            value = keyVal[1][1:(- 1)]
        return (operation, key, value.strip())

    def addToDictionary(self, reqID, val, key):
        try:
            self._state.data[reqID] = ['OK', val, key]
            return 'OK'
        except:
            self._state.data[reqID] = ['fail', val, key]
            return 'fail'

    def getFrom(self, reqID, val, key):
        try:
            self.output('reqID', reqID, level=10)
            getreqID = [k for (k, v) in self._state.data.items() if (key in v)][(- 1)]
            getVal = self._state.data[getreqID][1]
            self.output('getVal', getVal, level=10)
            self._state.data[reqID] = [getVal, getVal, key]
            return self._state.data[reqID][0]
        except:
            self.output('entered exception', level=10)
            self._state.data[reqID] = ['', '', key]
            return ''

    def appendDictionary(self, reqID, val, key):
        try:
            getreqID = [k for (k, v) in self._state.data.items() if (key in v)][(- 1)]
            self.output('-----getreqID----', getreqID, level=10)
            getVal = self._state.data[getreqID][1]
            newVal = (getVal + val)
            self.output('-----newVal----', newVal, level=10)
            self._state.data[reqID] = ['OK', newVal, key]
            return 'OK'
        except:
            self._state.data[reqID] = ['fail', '', key]
            return 'fail'

    def sliceDictionary(self, reqID, val, key):
        try:
            value = self._state.data[reqID][1]
            indices = val.split(':')
            self._state.data[reqID] = ['OK', value[int(indices[0]):int(indices[1])], key]
            return 'OK'
        except:
            self._state.data[reqID] = ['fail', '', key]
            return 'fail'

    def executeOperation(self, operation, reqID, val, key):
        self.output('--------------- Executing Operation to updata client dictionary with: --------------', operation, reqID, val, key, level=20)
        function_launch = {'put': self.addToDictionary, 'get': self.getFrom, 'append': self.appendDictionary, 'slice': self.sliceDictionary}
        return function_launch[operation](reqID, val, key)

    def _Client_handler_1577(self, Configuration, p):
        self.output('--------------- Received Configuration from Olympus --------------', level=20)
        self._state.replicas = Configuration
        operations = self.getOperations()
        self.output('--------------- Operations for Client --------------', operations, level=20)
        messageNumber = 0
        for noi in range(len(operations)):
            requestID = self.returnRandomNumber()
            self.output('--------------- Sending Request No: % :: Request Id: % --------------', noi, requestID, level=20)
            self.sendRequest(messageNumber, requestID, operations[noi], Configuration[0], 'initial')
            self.output('--------------- Waiting for Result --------------', noi, requestID, level=20)
            super()._label('_st_label_1640', block=False)
            resultShuttle = None

            def ExistentialOpExpr_1641():
                nonlocal resultShuttle
                for (_, _, (_ConstantPattern1658_, resultShuttle)) in self._ClientReceivedEvent_1:
                    if (_ConstantPattern1658_ == 'result'):
                        if (int(resultShuttle[0]) == requestID):
                            return True
                return False
            _st_label_1640 = 0
            self._timer_start()
            while (_st_label_1640 == 0):
                _st_label_1640 += 1
                if ExistentialOpExpr_1641():
                    messageNumber += 1
                    continue
                    _st_label_1640 += 1
                elif self._timer_expired:
                    self.output('--------------- TIMEOUT --------------', noi, requestID, level=20)
                    self.output('--------------- Sending Retransmission Request for Request No: % :: Request Id: % --------------', noi, requestID, level=20)
                    self.sendRequest(messageNumber, requestID, operations[noi], Configuration, 'retransmission')
                    messageNumber += 1
                    continue
                    _st_label_1640 += 1
                else:
                    super()._label('_st_label_1640', block=True, timeout=self._state.TIMEOUT)
                    _st_label_1640 -= 1
            else:
                if (_st_label_1640 != 2):
                    continue
            if (_st_label_1640 != 2):
                break
    _Client_handler_1577._labels = None
    _Client_handler_1577._notlabels = None

    def _Client_handler_1700(self, resultShuttle, tail):
        self.output('--------------- Received Result Shuttle --------------', level=20)
        self.output('result for request ID:', resultShuttle[0], level=10)
        (val, globalVal) = self.checkExpectedResult(resultShuttle[0])
        receivedResult = resultShuttle[1]
        (rDigest, rEncodedMessage) = self._state.utilities.hashResult(receivedResult)
        resultVerified = self.verifyResultProofs(resultShuttle[2], rDigest)
        self.output('--------------- Result Proof Verification check: % --------------', resultVerified, level=20)
        self.output('--------------- Client Dictionary Result: % --------------', val, level=20)
        self.output('--------------- Global Dictionary Result: % --------------', globalVal, level=20)
        self.output('--------------- Result From Replica: % --------------', receivedResult, level=20)
        if ((val == receivedResult) or (globalVal[0] == receivedResult) or (globalVal[1] == receivedResult)):
            self.output('---------------  RESULT IS ACCEPTED --------------', level=20)
        else:
            self.output('--------------- (RESULT IS REJECTED) --------------', level=20)
    _Client_handler_1700._labels = None
    _Client_handler_1700._notlabels = None

class Replica(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ReplicaReceivedEvent_3 = []
        self._ReplicaReceivedEvent_5 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_0', PatternExpr_2872, sources=[PatternExpr_2887], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2871]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_1', PatternExpr_3244, sources=[PatternExpr_3266], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3243]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_2', PatternExpr_3755, sources=[PatternExpr_3768], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3754]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_3', PatternExpr_3910, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_4', PatternExpr_3983, sources=[PatternExpr_3994], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_3982]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_5', PatternExpr_4089, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_6', PatternExpr_4581, sources=[PatternExpr_4591], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_4580])])

    def setup(self, p, i, Mode, replica_signing_key, clients, replicas, **rest_5707):
        super().setup(p=p, i=i, Mode=Mode, replica_signing_key=replica_signing_key, clients=clients, replicas=replicas, **rest_5707)
        self._state.p = p
        self._state.i = i
        self._state.Mode = Mode
        self._state.replica_signing_key = replica_signing_key
        self._state.clients = clients
        self._state.replicas = replicas
        self._state.terminate = False
        self._state.utilities = Utils()
        self._state.data = dict()
        self._state.replicaHistory = dict()
        self._state.resultCache = dict()
        self._state.slot = 0
        self._state.shuttleNumber = 0
        self._state.resultShuttleNumber = 0
        self._state.globalConfig = dict()
        self._state.noOfReplicas = 0
        self._state.ReplicaTIMEOUT = 0
        self._state.HeadTIMEOUT = 0
        self._state.failuresDict = dict()
        self._state.forwardRequestMessageNo = 0

    def run(self):
        self.output('--------------- Entering Replica Run: --------------', level=20)
        self._state.globalConfig = readConfigFile()
        self._state.noOfReplicas = ((2 * self._state.globalConfig['t']) + 1)
        self._state.ReplicaTIMEOUT = self._state.globalConfig['nonhead_timeout']
        self._state.HeadTIMEOUT = self._state.globalConfig['head_timeout']
        (foundFailures, failures) = self.getFailures()
        if (not (foundFailures == 'No Failures')):
            failuresList = failures.split(';')
            self.fTfAMapping(failuresList)
        self.output('--------------- Failures for Replica: --------------', foundFailures, level=20)
        self.output(self._state.failuresDict, level=20)
        super()._label('_st_label_2746', block=False)
        _st_label_2746 = 0
        while (_st_label_2746 == 0):
            _st_label_2746 += 1
            if self._state.terminate:
                _st_label_2746 += 1
            else:
                super()._label('_st_label_2746', block=True)
                _st_label_2746 -= 1

    def getFailures(self):
        self.output('--------------- Getting Failures for Replica : --------------', level=20)
        try:
            failureIndex = (('failures[0,' + str(self._state.i)) + ']')
            return ('Failures', self._state.globalConfig[failureIndex])
        except:
            return ('No Failures', None)

    def fTfAMapping(self, failuresList):
        self.output('--------------- Creating Failure Trigger and Failure Action Mapping: --------------', level=20)
        for eachFailure in failuresList:
            ft = (eachFailure.split(')')[0].strip() + ')')
            fa = (eachFailure.split(')')[1].split(',')[1].strip() + ')')
            self._state.failuresDict[ft] = fa

    def hashResult(self, r):
        self.output('--------------- Creating hash digest for result ---------------', level=20)
        HASHER = nacl.hash.sha256
        digest = HASHER(bytes(r, 'utf-8'), encoder=nacl.encoding.HexEncoder)
        encodedMessage = nacl.encoding.HexEncoder.encode(bytes(r, 'utf-8'))
        return (digest.decode('utf-8'), encodedMessage.decode('utf-8'))

    def checkHashResult(self, digest, rDigest):
        self.output('--------------- Checking hash digests for results ---------------', level=20)
        bDigest = bytes(digest, 'utf-8')
        brDigest = bytes(rDigest, 'utf-8')
        if sodium_memcmp(bDigest, brDigest):
            return True
        return False

    def createStatements(self, s, o, r):
        self.output((((((('--- Create Signed Order Statement and Result Statement with: slot: ' + str(s)) + ', operation: ') + str(o)) + ', result') + str(r)) + '--------------'), level=20)
        orderStatement = bytes(str(((("'order';" + str(s)) + ';') + o.decode('utf-8'))), 'utf8')
        signedOrderStatement = self._state.utilities.signTheStatement(self._state.replica_signing_key, orderStatement)
        (rDigest, encodedResult) = self._state.utilities.hashResult(r)
        resultStatement = bytes(((((("'result';" + str(s)) + ';') + rDigest) + ';') + encodedResult), 'utf8')
        signedResultStatement = self._state.utilities.signTheStatement(self._state.replica_signing_key, resultStatement)
        return (signedOrderStatement, signedResultStatement)

    def checkForFailure(self, failureTrigger):
        self.output('--------------- Get Failure Action --------------', level=20)
        try:
            failureAction = self._state.failuresDict[failureTrigger]
            return ('foundFailure', failureAction)
        except:
            return ('notFound', None)

    def checkOrderProofIntegerity(self, slot, verifiedClientStatement, tempOrderProof):
        self.output('--------------- Check for Result Proof Integrity:[Result-Statements:Signatures] and Result--------------', level=20)
        numOfOP = len(tempOrderProof)
        tempii = 0
        verified = ''
        while (tempii < numOfOP):
            temp_verify_key = self._state.utilities.decodeVerifyKey(self._state.replicas[tempii][1])
            tempSignedOP = tempOrderProof[tempii]
            try:
                verified = self._state.utilities.verifyTheStatement(temp_verify_key, tempSignedOP)
                tempOrderStatement = verified.decode('utf-8').split(';')
                tempSlot = tempOrderStatement[1]
                tempSignedStatement = tempOrderStatement[2]
                if ((not (str(slot) == tempSlot)) or (not (tempSignedStatement == verifiedClientStatement))):
                    verified = 'False'
                else:
                    verified = 'True'
            except:
                verified = 'False'
                break
            tempii += 1
        return verified

    def verifyResultProofs(self, tempResultProof):
        self.output('--------------- Verifying:[Result-Statements:Signatures] --------------', level=20)
        numOfRP = len(tempResultProof)
        tempi = 0
        verified = ''
        if (numOfRP == 0):
            return 'False'
        while (tempi < numOfRP):
            try:
                temp_verify_key = self._state.utilities.decodeVerifyKey(self._state.replicas[tempi][1])
                tempSignedRP = tempResultProof[tempi]
                verified = self._state.utilities.verifyTheStatement(temp_verify_key, tempSignedRP)
                verified = 'True'
            except:
                verified = 'False'
                break
            tempi += 1
        return verified

    def checkResultProofIntegerity(self, tempResultProof, rDigest):
        self.output('--------------- Check for Result Proof Integrity:[Result-Statements:Signatures] and Result--------------', level=20)
        numOfRP = len(tempResultProof)
        tempii = 0
        verified = ''
        while (tempii < numOfRP):
            temp_verify_key = self._state.utilities.decodeVerifyKey(self._state.replicas[tempii][1])
            tempSignedRP = tempResultProof[tempii]
            try:
                verified = self._state.utilities.verifyTheStatement(temp_verify_key, tempSignedRP)
                strVerified = verified.decode('utf8')
                verifiedTuple = strVerified.split(';')
                if self._state.utilities.checkHashResult(verifiedTuple[2], rDigest):
                    verified = 'True'
                else:
                    verified = 'False'
                    break
            except:
                verified = 'False'
                break
            tempii += 1
        return verified

    def checkRequestIDInHistory(self, reqID):
        self.output((('--------------------- Check for Request Id: ' + str(reqID)) + ' in history-----------------------'), level=20)
        return (reqID in [x for v in self._state.replicaHistory.values() for x in v])

    def checkSlotInHistory(self, slot, operation):
        inHistory = 'false'
        self.output('--------------- Check for <Slot,Operation> Integrity--------------', level=20)
        try:
            op = self._state.replicaHistory[slot][0]
            self.output('op', op)
            if (operation == op):
                inHistory = 'validOperation'
            elif (not (operation == op)):
                inHistory = 'invalidOperation'
        except:
            pass
        return inHistory

    def checkForHoles(self, slot):
        self.output('--------------- Check for holes in Replica history --------------', level=20)
        holes = False
        if (slot == 0):
            return holes
        try:
            op = self._state.replicaHistory[(slot - 1)]
        except:
            holes = True
        return holes

    def unionOrderProofs(self, orderProof, signedOS):
        self.output('--------------- Making union of order statements: Order Proof --------------', level=20)
        return orderProof.append(signedOS)

    def unionResultProofs(self, resultProof, signedRS):
        self.output('--------------- Making union of result statements: Result Proof --------------', level=20)
        return resultProof.append(signedRS)

    def appendToReplicaHistory(self, s, o, orderProof, reqID):
        self.output((((((('-------------------------- Append to Replica History slot:' + str(s)) + ' operation:') + str(o)) + ' request Id:') + str(reqID)) + ' --------------'), level=20)
        self._state.replicaHistory[s] = (o.decode('utf-8'), orderProof, reqID)

    def appendToResultCache(self, resultSh):
        self.output('--------------- Append Result to Result Cache --------------', level=20)
        self._state.resultCache[resultSh[0]] = (resultSh[1], resultSh[2])

    def getResultFromResultCache(self, requestID):
        self.output('--------------- Get Result From Result Cache --------------', level=20)
        try:
            tempResult = self._state.resultCache[requestID]
            return ('Found', (requestID, tempResult[0], tempResult[1]))
        except KeyError:
            return ('NoResult', None)

    def changeOperation(self):
        return 'get'

    def changeResult(self):
        return 'OK'

    def dropResultStatement(self, resultProofToTruncate):
        self.output('--------------- Dropping Heads Result Statement --------------', level=20)
        numOfRP = len(resultProofToTruncate)
        verified = ''
        temp_verify_key = self._state.utilities.decodeVerifyKey(self._state.replicas[0][1])
        tempSignedRP = resultProofToTruncate[0]
        try:
            verified = self._state.utilities.verifyTheStatement(temp_verify_key, tempSignedRP)
            resultProofToTruncate.pop(0)
        except:
            verified = 'False'
        return resultProofToTruncate

    def parseTheUnsignedStatement(self, unSignedRequestStatement):
        self.output('--------------- Parsing the unsigned statement --------------', level=20)
        inp = str(unSignedRequestStatement, 'utf-8')
        inp = inp.split(')')[0]
        opKeyVal = inp.split('(')
        operation = opKeyVal[0]
        keyVal = opKeyVal[1].split(',')
        key = keyVal[0][1:(- 1)]
        value = ''
        if (not (operation == 'get')):
            value = keyVal[1][1:(- 1)]
        return (operation, key, value.strip())

    def addToDictionary(self, key, val):
        try:
            self._state.data[key] = val
            return 'OK'
        except:
            return 'Fail'

    def getFrom(self, key, val):
        try:
            return self._state.data[key]
        except:
            return ''

    def appendDictionary(self, key, val):
        try:
            valueExsist = self._state.data[key]
            self._state.data[key] = (valueExsist + val)
            return 'OK'
        except:
            return 'fail'

    def sliceDictionary(self, key, val):
        try:
            value = self._state.data[key]
            indices = val.split(':')
            self._state.data[key] = value[int(indices[0]):int(indices[1])]
            return 'OK'
        except:
            return 'fail'

    def executeOperation(self, operation, key, val):
        self.output('--------------- Executing Operation to updata client dictionary with: --------------', level=20)
        function_launch = {'put': self.addToDictionary, 'get': self.getFrom, 'append': self.appendDictionary, 'slice': self.sliceDictionary}
        return function_launch[operation](str(key), str(val))

    def _Replica_handler_2871(self, messageNumber, clientId, requestID, signedRequestStatement, operationCount, c):
        self.output('--------------------- Head:receives:signedRequestStatement from client -----------------------', level=20)
        self.output((((((('--------------------- Received Request message number:[' + str(messageNumber)) + ' ; client Id: [') + str(clientId)) + '] ; request Id: [') + str(requestID)) + ']-----------------------'), level=20)
        orderProof = list()
        resultProof = list()
        temp_verify_key = self._state.utilities.decodeVerifyKey(self._state.clients[clientId][1])
        unSignedRequestStatement = ''
        operation = ''
        if ((self._state.Mode == 'ACTIVE') and (not self.checkRequestIDInHistory(requestID))):
            verified = ''
            try:
                verified = self._state.utilities.verifyTheStatement(temp_verify_key, signedRequestStatement)
            except:
                verified = 'Not verified'
            self.output('--------------------- Unsigned Statement from client -----------------------', verified, level=20)
            (operation, key, value) = self._state.utilities.parseTheUnsignedStatement(verified)
            self.output('--------------------- Checking for failures -----------------------', level=20)
            failureClientRequest = (((('client_request(' + str(clientId)) + ',') + str(messageNumber)) + ')')
            (fStatus, getAction) = self.checkForFailure(failureClientRequest)
            self.output((((('--------------------- Failure Check:[' + str(fStatus)) + '] Failure action:') + str(getAction)) + '-----------------------'), level=20)
            if (not (fStatus == 'notFound')):
                if (getAction == 'change_operation()'):
                    operation = self.changeOperation()
                    key = 'x'
                    verified = bytes("get('x')", 'utf-8')
                    self.output((((('---------------------Changed Operation:[' + str(operation)) + '] Key:') + key) + '-----------------------'), level=20)
            result = self.executeOperation(operation, key, value)
            self.output((((('--------------------- Failure Check:[' + str(fStatus)) + '] Failure action:') + str(getAction)) + '-----------------------'), level=20)
            if (not (fStatus == 'notFound')):
                if (getAction == 'change_result()'):
                    result = self.changeResult()
                    self.output('---------------------Changed result:', result, level=20)
            self.output('--------------------- Signing the statement:', verified, level=20)
            (signedOrderStatement, signedResultStatement) = self.createStatements(self._state.slot, verified, result)
            orderProof.append(signedOrderStatement)
            resultProof.append(signedResultStatement)
            self.output((((('--------------------- Failure Check:[' + str(fStatus)) + '] Failure action:') + str(getAction)) + '-----------------------'), level=20)
            if (not (fStatus == 'notFound')):
                if (getAction == 'drop_result_stmt()'):
                    resultProof = self.dropResultStatement(resultProof)
            self.output('--------------------- Data in Client Dictionary ', self._state.data, level=20)
            self.output('--------------------- Creating Shuttle -----------------------', level=20)
            shuttle = (orderProof, resultProof)
            self.appendToReplicaHistory(self._state.slot, verified, orderProof, requestID)
            self.output('--------------------- Sending Statement to Olympus coming from client: ', clientId, level=20)
            self.send(('headOperation', clientId, requestID, self._state.slot, signedRequestStatement), to=self._state.p)
            self.output((((('--------------------- Sending Statement:: message number' + str(messageNumber)) + ' from client: ') + str(clientId)) + ' to Next Replica -----------------------'), level=20)
            self.send((messageNumber, clientId, requestID, self._state.slot, signedRequestStatement, shuttle, 'initial', 'nonhead', operationCount, self._state.shuttleNumber), to=self._state.replicas[(self._state.i + 1)][0])
            self.output('------------------------------------------------------------', level=20)
            self._state.slot += 1
            self._state.shuttleNumber += 1
        elif self.checkRequestIDInHistory(requestID):
            self.output('---------------------NO EXECUTION: Request already found in History -----------------------', level=20)
        else:
            self.output('---------------------NO EXECUTION: Replica is not Active-----------------------', level=20)
    _Replica_handler_2871._labels = None
    _Replica_handler_2871._notlabels = None

    def _Replica_handler_3243(self, messageNumber, clientId, requestID, tempSlot, signedRequestStatement, shuttle, typeOfRequest, replicaType, operationCount, shuttleNumber, previousReplica):
        self.output('--------------------- Replica:receives:signedRequestStatement from previous replica -----------------------', level=20)
        self.output((((((('--------------------- Received Request message number:[' + str(messageNumber)) + ' ; client Id: [') + str(clientId)) + '] ; request Id: [') + str(requestID)) + ']-----------------------'), level=20)
        if ((self._state.i < self._state.noOfReplicas) and (self._state.Mode == 'ACTIVE')):
            tempOrderProof = shuttle[0]
            tempResultProof = shuttle[1]
            temp_verify_key = self._state.utilities.decodeVerifyKey(self._state.clients[clientId][1])
            verifiedClientStatement = ''
            try:
                verifiedClientStatement = self._state.utilities.verifyTheStatement(temp_verify_key, signedRequestStatement)
            except:
                verifiedClientStatement = 'Not verified'
            self.output('--------------------- Unsigned Statement from client -----------------------', verifiedClientStatement, level=20)
            (operation, key, value) = self._state.utilities.parseTheUnsignedStatement(verifiedClientStatement)
            checkedOrderProofs = self.checkOrderProofIntegerity(tempSlot, str(verifiedClientStatement, 'utf-8'), tempOrderProof)
            self.output('--------------------- Verifying Order Proofs -----------------------', checkedOrderProofs, level=20)
            resultsVerified = self.verifyResultProofs(tempResultProof)
            self.output('--------------------- Verifying Result Proofs -----------------------', resultsVerified, level=20)
            if ((not (checkedOrderProofs == 'False')) and (not (resultsVerified == 'False'))):
                self.output('--------------------- Checking for failures -----------------------', level=20)
                failureShuttleRequest = (((('shuttle(' + str(clientId)) + ',') + str(shuttleNumber)) + ')')
                (fStatus, getAction) = self.checkForFailure(failureShuttleRequest)
                self.output((((('--------------------- Failure Check:[' + str(fStatus)) + '] Failure action:') + str(getAction)) + '-----------------------'), level=20)
                if (not (fStatus == 'notFound')):
                    if (getAction == 'change_operation()'):
                        operation = self.changeOperation()
                        key = 'x'
                        verifiedClientStatement = bytes("get('x')", 'utf-8')
                        self.output((((('--------------------- Changed Operation:[' + str(operation)) + '] Key:') + key) + '-----------------------'), level=20)
                        self.output((('--------------------- Changed Verified Client Statement: ' + str(verifiedClientStatement)) + '--------------------'), level=20)
                inHistory = self.checkSlotInHistory(int(tempSlot), verifiedClientStatement)
                holes = self.checkForHoles(int(tempSlot))
                self.output((((('--------------------- Slot Consistency: ' + str(inHistory)) + ' Holes Found: ') + str(holes)) + '--------------------'), level=20)
                if ((inHistory == 'false') and (holes == False)):
                    result = self.executeOperation(operation, key, value)
                    self.output((((('--------------------- Failure Check:[' + str(fStatus)) + '] Failure action:') + str(getAction)) + '-----------------------'), level=20)
                    if (not (fStatus == 'notFound')):
                        if (getAction == 'change_result()'):
                            result = self.changeResult()
                            self.output((('---------------------Changed result:[' + result) + '] -----------------------'), level=20)
                    (tempSignedOrderStatement, tempSignedResultStatement) = self.createStatements(tempSlot, verifiedClientStatement, result)
                    tempOrderProof.append(tempSignedOrderStatement)
                    tempResultProof.append(tempSignedResultStatement)
                    self.output((((('--------------------- Failure Check:[' + str(fStatus)) + '] Failure action:') + str(getAction)) + '-----------------------'), level=20)
                    if (not (fStatus == 'notFound')):
                        if (getAction == 'drop_result_stmt()'):
                            tempResultProof = self.dropResultStatement(tempResultProof)
                    self.output('--------------------- Data in Client Dictionary ', self._state.data, level=20)
                    self.appendToReplicaHistory(tempSlot, verifiedClientStatement, tempOrderProof, requestID)
                    self.output('--------------------- Creating Shuttle -----------------------', level=20)
                    shuttle = (tempOrderProof, tempResultProof)
                    if (not (self._state.i == (self._state.noOfReplicas - 1))):
                        self.output((((('--------------------- Sending Statement:: message number' + str(messageNumber)) + ' from client: ') + str(clientId)) + ' to Next Replica -----------------------'), level=20)
                        self.send((messageNumber, clientId, requestID, tempSlot, signedRequestStatement, shuttle, 'initial', 'nonhead', operationCount, shuttleNumber), to=self._state.replicas[(self._state.i + 1)][0])
                    elif (self._state.i == (self._state.noOfReplicas - 1)):
                        self.output('--------------------- Creating Result Shuttle: -----------------------', level=20)
                        resultShuttle = (requestID, result, tempResultProof)
                        self.appendToResultCache(resultShuttle)
                        self.output((((('--------------------- Sending ResultShuttle: No:[' + str(self._state.resultShuttleNumber)) + '] to Previous Replica: [') + str((self._state.i - 1))) + '] -----------------------'), level=20)
                        self.output((((('--------------------- Sending ResultShuttle: No:[' + str(self._state.resultShuttleNumber)) + '] to Client: [') + str(clientId)) + '] -----------------------'), level=20)
                        self.send(('result', resultShuttle, self._state.resultShuttleNumber, clientId), to=self._state.replicas[(self._state.i - 1)][0])
                        self._state.resultShuttleNumber += 1
                    else:
                        self.output('-------------------------------------------------------')
                else:
                    self.output('--------------------- SEND RECONFIGURATION REQUEST TO OLYMPUS -----------------------', level=20)
            else:
                self.output('--------------------- SEND RECONFIGURATION REQUEST TO OLYMPUS -----------------------', level=20)
        else:
            self.output('--------------------- NO EXECUTION: Replica is not Active -----------------------', level=20)
    _Replica_handler_3243._labels = None
    _Replica_handler_3243._notlabels = None

    def _Replica_handler_3754(self, messageNumber, clientId, requestID, signedRequestStatement, c):
        self.output('--------------------- Replica:receives:retransmission from Client -----------------------', level=20)
        self.output((((('--------------------- Request client Id: [' + str(clientId)) + '] ; request Id: [') + str(requestID)) + ']-----------------------'), level=20)
        temp_verify_key = self._state.utilities.decodeVerifyKey(self._state.clients[clientId][1])
        verified = ''
        try:
            verified = self._state.utilities.verifyTheStatement(temp_verify_key, signedRequestStatement)
        except:
            verified = 'Not verified'
        self.output((('--------------------- Unsigned Statement from client ' + str(verified)) + '-----------------------'), level=20)
        if (not (verified == 'Not Verified')):
            if (self._state.Mode == 'IMMUTABLE'):
                self.output((('--------------------- IMMUTABLE REPLICA: Send Error Statement to ClientId: [' + str(clientId)) + ']-----------------------'), level=20)
                self.send(('errorStatement',), to=self._state.clients[clientId][0])
            else:
                (resultFound, resultShuttle) = self.getResultFromResultCache(requestID)
                self.output((('---------------------' + resultFound) + ' in Result Cache-----------------------'), level=20)
                if (resultFound == 'NoResult'):
                    if (not (self._state.i == 0)):
                        self.output((((('--------------------- Sending forward-request to head coming from client Id: [' + str(clientId)) + '] ; with request Id: [') + str(requestID)) + ']-----------------------'), level=20)
                        self.send(('forwardRequest', clientId, requestID, signedRequestStatement), to=self._state.replicas[0][0])
                        self.output('--------------------- Waiting for result shuttle to arrive-----------------------', level=20)
                        super()._label('_st_label_3907', block=False)
                        resultShuttle = result = None

                        def ExistentialOpExpr_3908():
                            nonlocal resultShuttle, result
                            for (_, _, (result, resultShuttle)) in self._ReplicaReceivedEvent_3:
                                if (int(resultShuttle[0]) == requestID):
                                    return True
                            return False
                        _st_label_3907 = 0
                        self._timer_start()
                        while (_st_label_3907 == 0):
                            _st_label_3907 += 1
                            if ExistentialOpExpr_3908():
                                self.output((('--------------------- Received Result Shuttle: Sending Shuttle to Client [' + str(clientId)) + ']-----------------------'), level=20)
                                self.send(('result', resultShuttle), to=self._state.clients[clientId][0])
                                _st_label_3907 += 1
                            elif self._timer_expired:
                                self.output('--------------------- Send Reconfiguration request to Olympus-----------------------', level=20)
                                _st_label_3907 += 1
                            else:
                                super()._label('_st_label_3907', block=True, timeout=self._state.ReplicaTIMEOUT)
                                _st_label_3907 -= 1
                elif (resultFound == 'Found'):
                    self.output((('--------------------- Result Found:Sending ResultShuttle:to Client: [' + str(clientId)) + '] -----------------------'), level=20)
                    self.send(('result', resultShuttle), to=self._state.clients[clientId][0])
    _Replica_handler_3754._labels = None
    _Replica_handler_3754._notlabels = None

    def _Replica_handler_3982(self, clientId, requestID, signedRequestStatement, p):
        self.output('--------------------- Replica:receives:forwardRequest from Previous Replica -----------------------', level=20)
        self.output((((('--------------------- Request client Id: [' + str(clientId)) + '] ; request Id: [') + str(requestID)) + ']-----------------------'), level=20)
        self._state.forwardRequestMessageNo += 1
        temp_verify_key = self._state.utilities.decodeVerifyKey(self._state.clients[clientId][1])
        verified = ''
        try:
            verified = self._state.utilities.verifyTheStatement(temp_verify_key, signedRequestStatement)
        except:
            verified = 'Not verified'
        self.output((('--------------------- Unsigned Statement from client ' + str(verified)) + '-----------------------'), level=20)
        if (not (verified == 'Not Verified')):
            (resultFound, resultShuttle) = self.getResultFromResultCache(requestID)
            self.output((('---------------------' + resultFound) + ' in Result Cache-----------------------'), level=20)
            if (resultFound == 'NoResult'):
                if self.checkRequestIDInHistory(requestID):
                    self.output('--------------------- Waiting for result shuttle to arrive-----------------------', level=20)
                    super()._label('_st_label_4086', block=False)
                    result = resultShuttle = None

                    def ExistentialOpExpr_4087():
                        nonlocal result, resultShuttle
                        for (_, _, (result, resultShuttle)) in self._ReplicaReceivedEvent_5:
                            if (int(resultShuttle[0]) == requestID):
                                return True
                        return False
                    _st_label_4086 = 0
                    self._timer_start()
                    while (_st_label_4086 == 0):
                        _st_label_4086 += 1
                        if ExistentialOpExpr_4087():
                            failureResultShuttle = (((('forwarded_request(' + str(clientId)) + ',') + str(self._state.forwardRequestMessageNo)) + ')')
                            (fStatus, getAction) = self.checkForFailure(failureResultShuttle)
                            self.output((((('--------------------- Failure Check:[' + str(fStatus)) + '] Failure action:') + str(getAction)) + '-----------------------'), level=20)
                            if (not (fStatus == 'notFound')):
                                if (getAction == 'change_result()'):
                                    lst = list(resultShuttle)
                                    lst[1] = self.changeResult()
                                    resultShuttle = tuple(lst)
                                    self.output((('--------------------- Changed result:[' + str(resultShuttle[1])) + '] -----------------------'), level=20)
                            self.output((((('--------------------- Failure Check:[' + str(fStatus)) + '] Failure action:') + str(getAction)) + '-----------------------'), level=20)
                            if (not (fStatus == 'notFound')):
                                if (getAction == 'drop_result_stmt()'):
                                    lst = list(resultShuttle)
                                    lst[2] = self.dropResultStatement(resultShuttle[2])
                                    resultShuttle = tuple(lst)
                            self.output((('--------------------- Received Result Shuttle: Sending Shuttle to Client [' + clientId) + ']-----------------------'), level=20)
                            self.send(('result', resultShuttle), to=self._state.clients[clientId][0])
                            _st_label_4086 += 1
                        elif self._timer_expired:
                            self.output('--------------------- Send Reconfiguration request to Olympus-----------------------', level=20)
                            continue
                            _st_label_4086 += 1
                        else:
                            super()._label('_st_label_4086', block=True, timeout=self._state.HeadTIMEOUT)
                            _st_label_4086 -= 1
                else:
                    self.output((((('--------------------- Start the Operation from scrath for client Id: [' + str(clientId)) + '] ; with request Id: [') + str(requestID)) + ']-----------------------'), level=20)
                    self.output('--------------------- Waiting for result shuttle to arrive-----------------------', level=20)
                    super()._label('_st_label_4274', block=False)
                    result = resultShuttle = None

                    def ExistentialOpExpr_4275():
                        nonlocal result, resultShuttle
                        for (_, _, (result, resultShuttle)) in self._ReplicaReceivedEvent_5:
                            if (int(resultShuttle[0]) == requestID):
                                return True
                        return False
                    _st_label_4274 = 0
                    self._timer_start()
                    while (_st_label_4274 == 0):
                        _st_label_4274 += 1
                        if ExistentialOpExpr_4275():
                            self.output((('--------------------- Received Result Shuttle: Sending Shuttle to Client [' + str(clientId)) + ']-----------------------'), level=20)
                            failureResultShuttle = (((('forwarded_request(' + str(clientId)) + ',') + str(self._state.forwardRequestMessageNo)) + ')')
                            (fStatus, getAction) = self.checkForFailure(failureResultShuttle)
                            self.output((((('--------------------- Failure Check:[' + str(fStatus)) + '] Failure action:') + str(getAction)) + '-----------------------'), level=20)
                            if (not (fStatus == 'notFound')):
                                if (getAction == 'change_result()'):
                                    lst = list(resultShuttle)
                                    lst[1] = self.changeResult()
                                    resultShuttle = tuple(lst)
                                    self.output((('--------------------- Changed result:[' + str(resultShuttle[1])) + '] -----------------------'), level=20)
                            self.output((((('--------------------- Failure Check:[' + str(fStatus)) + '] Failure action:') + str(getAction)) + '-----------------------'), level=20)
                            if (not (fStatus == 'notFound')):
                                if (getAction == 'drop_result_stmt()'):
                                    lst = list(resultShuttle)
                                    lst[2] = self.dropResultStatement(resultShuttle[2])
                                    resultShuttle = tuple(lst)
                            self.send(('result', resultShuttle), to=self._state.clients[clientId][0])
                            _st_label_4274 += 1
                        elif self._timer_expired:
                            self.output('--------------------- Send Reconfiguration request to Olympus-----------------------', level=20)
                            _st_label_4274 += 1
                        else:
                            super()._label('_st_label_4274', block=True, timeout=self._state.HeadTIMEOUT)
                            _st_label_4274 -= 1
            elif (resultFound == 'Found'):
                self.output((('--------------------- Result Found:Sending ResultShuttle:to Client: [' + str(clientId)) + '] -----------------------'), level=20)
                failureResultShuttle = (((('forwarded_request(' + str(clientId)) + ',') + str(self._state.forwardRequestMessageNo)) + ')')
                (fStatus, getAction) = self.checkForFailure(failureResultShuttle)
                self.output((((('--------------------- Failure Check:[' + str(fStatus)) + '] Failure action:') + str(getAction)) + '-----------------------'), level=20)
                if (not (fStatus == 'notFound')):
                    if (getAction == 'change_result()'):
                        lst = list(resultShuttle)
                        lst[1] = self.changeResult()
                        resultShuttle = tuple(lst)
                        self.output((('--------------------- Changed result:[' + str(resultShuttle[1])) + '] -----------------------'), level=20)
                self.output((((('--------------------- Failure Check:[' + str(fStatus)) + '] Failure action:') + str(getAction)) + '-----------------------'), level=20)
                if (not (fStatus == 'notFound')):
                    if (getAction == 'drop_result_stmt()'):
                        lst = list(resultShuttle)
                        lst[2] = self.dropResultStatement(resultShuttle[2])
                        resultShuttle = tuple(lst)
                self.send(('result', resultShuttle), to=self._state.clients[clientId][0])
    _Replica_handler_3982._labels = None
    _Replica_handler_3982._notlabels = None

    def _Replica_handler_4580(self, resultShuttle, resultShuttleNumber, clientId, nextReplica):
        self.output('-------------------- Received Result Shuttle from Next Replica -------------------------', level=20)
        self.output((((('--------------------- Received Result Shuttle: Result Shuttle No.' + str(resultShuttleNumber)) + ' for Client [') + str(clientId)) + ']-----------------------'), level=20)
        receivedResult = resultShuttle[1]
        self.output('receivedResult', receivedResult)
        (rDigest, rEncodedMessage) = self._state.utilities.hashResult(receivedResult)
        resultVerified = self.checkResultProofIntegerity(resultShuttle[2], rDigest)
        if (not (resultVerified == 'False')):
            failureResultShuttle = (((('result_shuttle(' + str(clientId)) + ',') + str(resultShuttleNumber)) + ')')
            (fStatus, getAction) = self.checkForFailure(failureResultShuttle)
            self.output((((('--------------------- Failure Check:[' + str(fStatus)) + '] Failure action:') + str(getAction)) + '-----------------------'), level=20)
            if (not (fStatus == 'notFound')):
                if (getAction == 'change_result()'):
                    lst = list(resultShuttle)
                    lst[1] = self.changeResult()
                    resultShuttle = tuple(lst)
                    self.output((('--------------------- Changed result:[' + str(resultShuttle[1])) + '] -----------------------'), level=20)
            self.output((((('--------------------- Failure Check:[' + str(fStatus)) + '] Failure action:') + str(getAction)) + '-----------------------'), level=20)
            if (not (fStatus == 'notFound')):
                if (getAction == 'drop_result_stmt()'):
                    lst = list(resultShuttle)
                    lst[2] = self.dropResultStatement(resultShuttle[2])
                    resultShuttle = tuple(lst)
            if (resultVerified == 'True'):
                self.appendToResultCache(resultShuttle)
            else:
                self.output('--------------------- Send Reconfiguration request to Olympus---------------', level=40)
            if (not (self._state.i == 0)):
                self.output((((('--------------------- Sending ResultShuttle: No:[' + str(resultShuttleNumber)) + '] to Previous Replica: [') + str((self._state.i - 1))) + '] -----------------------'), level=20)
                self.send(('result', resultShuttle, resultShuttleNumber, clientId), to=self._state.replicas[(self._state.i - 1)][0])
        else:
            self.output('---------------------Send Reconfiguration request to Olympus---------------', level=40)
    _Replica_handler_4580._labels = None
    _Replica_handler_4580._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def run(self):
        self.output('---------------ENTERING main---------------------')
        olympus = self.new(Olympus, args=(), at='olympus')
        self._start(olympus)
