import sys
import nacl.utils
from random import *
import random
import nacl.encoding
import nacl.hash
from nacl.bindings.utils import sodium_memcmp
import nacl.signing
import logging
# from nacl.public import PrivateKey,Box
# from nacl.encoding import Base64Encoder

def readConfigFile():
    # output("---------------ENTERING readConfigFile ---------------------")
    config = dict()
    with open('config.csv','r') as f:  
        for line in f:
            if line[0] != '#':
                (key,sep,val) = line.partition('=')
                # if the line does not contain '=', it is invalid and hence ignored
                if len(sep) != 0:
                    val = val.strip()
                    config[key.strip()] = int(val) if str.isdecimal(val) else val
    # print(config)
    return config





def signTheStatement(signing_key,message):
    return signing_key.sign(message)
    output('-------------Signed the message---------------------------')

# def createABox(prKey,pubKey):
#     return Box(prKey, pubKey)

def decodeVerifyKey(verify_key_hex):
    return nacl.signing.VerifyKey(verify_key_hex, encoder=nacl.encoding.HexEncoder)

def verifyTheStatement(verify_key,signed):
    return verify_key.verify(signed)       
    
class Olympus(process):
    globalConfig = dict()
    clients = []
    replicas = []
    # publicKeyClients =dict()
    # publicKeyReplicas=dict()
    # privateKeyClients =dict()
    # privateKeyReplicas=[]
    def setup():

        # logger = logging.getLogger(__name__)
        # logger.setLevel(logging.INFO)

        # logger.info('-------------------ENTER Olympu: setup---------------')
        output("---------------ENTERING Olymus:setup ---------------------",level=20)
        output(self)
        self.terminate = False
        self.client_signing_keys=dict()
        self.client_verify_keys_hex= dict()
        self.replica_signing_keys=dict()
        self.replica_verify_keys_hex= dict()

        # self.globalConfig = readConfigFile()
        # readGlobalConfigFile()
        initialSetup()
        # privateKeyClients,publicKeyClients = createClientKeys()
        # print(privateKeyClients)
        # privateKeyReplicas,publicKeyReplicas=createReplicaKeys()
        # clients = createClientProcesses(privateKeyClients)
        # replicas = createReplicaProcesses(privateKeyReplicas,publicKeyClients,publicKeyReplicas)
        # createProcesses()
        # print()

    def run():
        # a = False
        await(terminate)

        #print(globalConfig)
        # await(received(('requestConfiguration',)))#, from_=p))
        # await(len(listof(p, received(('requestConfiguration',), from_=p))) == 1)
        # await(received(('Received Configuration',)))
        #await(received(('reconfigurationRequests',)))
        output('terminating')

    def receive(msg=('requestConfiguration',), from_=p):
        output("---------------ENTERING olympus:receieve:requestConfiguration---------------------")
        output(p)
        Configuration = replicas
        send((Configuration,), to=p)
    
    def readGlobalConfigFile():
        output("---------------ENTERING Olymus:readGlobalConfigFile ---------------------")
        globalConfiggg = readConfigFile()
        output("----EXIT-----")


    def initialSetup():
        output("---------------ENTERING Olymus:initialSetup ---------------------")
        globalConfig = readConfigFile()
        noOfClients = globalConfig['num_client']
        noOfReplicas = 2*globalConfig['t'] + 1
        # privateKeyClients,publicKeyClients = createClientKeys()
        # privateKeyReplicas,publicKeyReplicas=createReplicaKeys()
        client_signing_keys, client_verify_keys_hex = createKeys(noOfClients)
        clients = createClientProcesses(client_signing_keys)
        replica_signing_keys, replica_verify_keys_hex = createKeys(noOfReplicas)
        replicas = createReplicaProcesses(replica_signing_keys,clients,replica_verify_keys_hex)
        # clients = createClientProcesses(privateKeyClients)
        # replicas = createReplicaProcesses(privateKeyReplicas,clients,publicKeyReplicas)


    # def createProcesses():
    #     print("---------------ENTERING createProcesses ---------------------")
    #     globalConfig = readConfigFile()
    #     clients = createClientProcesses()
    #     replicas = createReplicaProcesses()
    #     print("---------------CREATED CLIENT AND REPLICA PROCESSES:: createProcesses ---------------------")

    #     print(clients)
    #     print(replicas)
        #setupClientProcesses(clients,publ)
        # setupReplicaProcesses(replicas,clients)
        #startProcesses()

    def createKeys(number):
        output("---------------ENTERING Olymus:createKeys ---------------------",level=40)
        signing_keys = dict()
        verify_keys_hex = dict()
        for i in range(number):
            signing_key=nacl.signing.SigningKey.generate()
            verify_key = signing_key.verify_key
            verify_key_hex = verify_key.encode(encoder=nacl.encoding.HexEncoder)
            signing_keys[i] = signing_key
            verify_keys_hex[i] = verify_key_hex
        return signing_keys,verify_keys_hex



    # def createClientKeys():
    #     print("---------------ENTERING Olymus:createClientKeys ---------------------")
    #     tempPublicKeys=dict()
    #     tempPrivateKeys=dict()
    #     noOfClients = globalConfig['num_client']
    #     print(noOfClients)
    #     # hosts = globalConfig['hosts'].split(';')
    #     # client_hosts=globalConfig['client_hosts'].split(';')
    #     for i in range(noOfClients):

    #         # processAtNode = 'Client'+str(i)+'@'+hosts[int(client_hosts[int(i)].strip())].strip() 
    #         processAtPrKey = PrivateKey.generate()
    #         processAtPuKey = processAtPrKey.public_key

    #         tempPrivateKeys[i] =  processAtPrKey
    #         tempPublicKeys[i] =  processAtPuKey


    #     return tempPrivateKeys,tempPublicKeys

    # def createReplicaKeys():
    #     print("---------------ENTERING Olymus:createReplicaKeys ---------------------")

    #     tempPublicKeys=dict()
    #     tempPrivateKeys=dict()
    #     noOfReplicas = 2*globalConfig['t'] + 1
    #     # hosts = globalConfig['hosts'].split(';')
    #     # replica_hosts=globalConfig['replica_hosts'].split(';')

    #     for i in range(noOfReplicas):
    #         # processAtNode = 'Replica'+str(i)+'@'+hosts[int(replica_hosts[int(i)].strip())].strip()
    #         processAtPrKey = PrivateKey.generate()
    #         processAtPuKey = processAtPrKey.public_key

    #         tempPrivateKeys[i] =  processAtPrKey
    #         tempPublicKeys[i] =  processAtPuKey
    #     return tempPrivateKeys,tempPublicKeys
        
    
    def createClientProcesses(client_signing_keys):       
        tempClients =[]
        output("---------------ENTERING CLIENT CREATE PROCESS---------------------")
        noOfClients = globalConfig['num_client']
        hosts = globalConfig['hosts'].split(';')
        client_hosts=globalConfig['client_hosts'].split(';')
        
        for i in range(noOfClients):
            processAtNode = 'Client'+str(i)
            # +'@'+hosts[int(client_hosts[int(i)].strip())].strip()            
            client = new(Client, at=processAtNode)
            setup(client, (self,i,client_signing_keys[i],))
            start(client)
            #tempClients.insert(i,(client,publicKeyReplicas[i]))
            tempClients.insert(i,(client,client_verify_keys_hex[i]))
        
        return tempClients

    def createReplicaProcesses(replica_signing_keys,clients,replica_verify_keys_hex):
        output("---------------ENTERING REPLICA CREATE PROCESS---------------------")
        tempReplicas =dict()
        noOfReplicas = 2*globalConfig['t'] + 1
        hosts = globalConfig['hosts'].split(';')
        replica_hosts=globalConfig['replica_hosts'].split(';')

        for i in range(noOfReplicas):
            processAtNode = 'Replica'+str(i)
            # +'@'+hosts[int(replica_hosts[int(i)].strip())].strip()
            replica = new(Replica,at=processAtNode)
            tempReplicas[i] = (replica,replica_verify_keys_hex[i])
            # tempReplicas.insert(i,(replica,publicKeyReplicas[i]))

        for i in range(noOfReplicas):
            setup(tempReplicas[i][0], (self,i,'ACTIVE',replica_signing_keys[i],clients,tempReplicas,))
            start(tempReplicas[i][0])
            
        return tempReplicas

    def createConfiguration():
        pass


    def setupProcesses():
        output("---------------ENTERING setupProcesses ---------------------")
        for i in range(noOfClients):
            setup(client[i], args=(self,))

    def startProcesses():
        output("---------------ENTERING startProcesses ---------------------")
        for i in range(noOfClients):
            start(client[i])


        
        
        

class Client(process):
     

    def setup(p,clientID,client_signing_key,): 
        self.terminate = False
        self.replicas = dict()
        self.TIMEOUT = 0
        self.globalConfig = dict()
        self.noOfReplicas =0
    
    def run():
        # print(processAtPrKey.encode(Base64Encoder))
        output("---------------ENTERING client:run---------------------")
        send(('requestConfiguration',), to=p)
        globalConfig = readConfigFile()
        TIMEOUT = globalConfig['client_timeout']
        noOfReplicas = 2*globalConfig['t'] + 1
        # await(some(received((Configuration), from_=p)))
        await(terminate)
        
        #send(('requestConfiguration',), to=p)
    def hashResult(r):
        output("---------------ENTERING hashResult ---------------------")
        HASHER = nacl.hash.sha256
        digest = HASHER(bytes(r,'utf-8'), encoder=nacl.encoding.HexEncoder)
        encodedMessage = nacl.encoding.HexEncoder.encode(bytes(r,'utf-8'))
        return digest.decode("utf-8"),encodedMessage.decode("utf-8")

    def checkHashResult(digest,rDigest):
        output("---------------ENTERING checkHashResult ---------------------")
        # orig_dgs = HASHER(encodedMessage, encoder=nacl.encoding.HexEncoder)
        bDigest=bytes(digest,'utf-8')
        brDigest = bytes(rDigest,'utf-8')
        if sodium_memcmp(bDigest, brDigest):
            return True
        return False

    def receive(msg=(Configuration,), from_=p):
        output("---------------ENTERING client:receive:Configuration---------------------")
        #config=readConfigFile()
        #noOfReplicas =  2*config('t')+1
        #output(noOfReplicas)
        #print(Configuration)
        replicas = Configuration
        output(len(Configuration))
        for x in range(len(Configuration)):
            print('Replica:',Configuration[x])
        operations = getOperations()
        output(operations)
        for i in range(len(operations)):
            output('------SENDING REQUESTS LOOP----------------')
            requestID = returnRandomNumber()
            output('requestID: ',requestID)
            output('------SENDING REQUESTS LOOP----------------')
            sendRequest(requestID,operations[i],Configuration[0],'initial')
            if await(some(received((result,resultShuttle,)), has=(int(resultShuttle[0]) == requestID))):
                # --end
                output("received result")
                continue
            elif timeout(TIMEOUT):
                output("Send Retransmission Request.")
                sendRequest(requestID,operations[i],Configuration,'retransmission')
                continue
                
        send(('Received Configuration',), to=p)

    def receive(msg=(result,resultShuttle),from_=tail):
        output('-------------------- Received Result Shuttle-----------------------')
        receivedResult = resultShuttle[1]
        rDigest,rEncodedMessage = hashResult(receivedResult)
        resultVerified = verifyResultProofs(resultShuttle[2],rDigest)
        output(resultVerified)
        output(resultShuttle)

    def getOperations():        
        cWorkLoad = globalConfig['workload['+str(self.clientID)+']']
        if 'pseudorandom' in cWorkLoad:
            seedAndNoOfRequests = cWorkLoad[:-1].split('(')[1].split(',')
            return generatePseudoRandomRequests(int(seedAndNoOfRequests[0]), int(seedAndNoOfRequests[1]))
        else:
            return cWorkLoad.split(';')



    def sendRequest(requestID,operation,receiver,typeOfRequest):
        
        output(operation)
        # requestStatement = b'initial'
        # requestStatement = bytes((requestID,str(operation.strip()),'initial'), 'utf8')
        requestStatement = bytes(str(operation.strip()),'utf8')
        output(requestStatement)
        #print(strRequestStatment)
        # box = createABox(client_signing_key,receiver[1])
        signedRequestStatement = signTheStatement(client_signing_key,requestStatement)
        # send(('done',), to=receiver[0])
        if typeOfRequest=='initial':
            send((typeOfRequest,clientID,requestID,signedRequestStatement,1), to=receiver[0])
        elif typeOfRequest == 'retransmission':
            for replicaNo in range(noOfReplicas):
                send((typeOfRequest,clientID,requestID,signedRequestStatement), to=receiver[replicaNo][0])


        output(signedRequestStatement)


    def generatePseudoRandomRequests(rSeed,noOfRequests):
        listofRequest = ["put('movie','star')","append('movie',' wars')","get('movie')","put('jedi,'luke skywalker)","slice('jedi','0:4')","get('jedi')"]
        random.seed(rSeed)
        requests = random.sample(listofRequest,k=noOfRequests)        
        return requests

    def returnRandomNumber():
        return randint(1, 10000)

    def verifyResultProofs(tempResultProof,rDigest):
        output("-----------------------verifyResultProofs---------------------------")
        #Number of order proofs
        numOfRP = len(tempResultProof)
        i=0
        verified = ''
        while i < numOfRP:
            temp_verify_key = decodeVerifyKey(replicas[i][1])
            tempSignedRP = tempResultProof[i]
            try:
                verified = verifyTheStatement(temp_verify_key,tempSignedRP)
                output(verified)
                strVerified = verified.decode('utf8')
                verifiedTuple = strVerified.split(';')
                output("--------------------verifying Digest",verifiedTuple[2])
                output('--------------------originalDigest',rDigest)
                if checkHashResult(verifiedTuple[2],rDigest):
                    verified = 'True'
                else:
                    verified = 'False'
            except:
                verified = 'Falsela'          
            i+=1
        return verified

class Replica(process):    
    
    
    def setup(p,i,Mode,replica_signing_key,clients,replicas):
        self.terminate = False
        self.data = dict()        
        self.replicaHistory = dict()
        self.resultCache = dict()
        self.slot = 0
        self.globalConfig = dict()
        self.noOfReplicas =0
        self.ReplicaTIMEOUT = 0
        self.HeadTIMEOUT = 0
        self.failuresList = list()
        self.failuresDict = dict()
    def run():
        output('---------------------ENTERING Replica:run-----------------------')
        output(p)
        output("------------------printing replicas with their public keys------------")        
        # await(some(received((rho,requestID,signedRequestStatement,typeOfRequest,), from_=previousReplica)))
        globalConfig = readConfigFile()
        # TIMEOUT = globalConfig['client_timeout']
        noOfReplicas = 2*globalConfig['t'] + 1
        ReplicaTIMEOUT = globalConfig['nonhead_timeout']
        HeadTIMEOUT = globalConfig['head_timeout']
        # failuresList.append(getFailures())
        # failuresDict.ge
        await(terminate)
        # await(some(received((clientId,requestID,signedRequestStatement,typeOfRequest,), from_=c)))
        output('--------------------Something------------------------')
        #awaitbvreceived previous replica
        # await(received(('done',)))

    # def getFailures():
    # 	return globalConfig['failures[0',+str(i)+']']

    # def parseFailures():


    def hashResult(r):
        output("---------------ENTERING hashResult ---------------------")
        HASHER = nacl.hash.sha256
        digest = HASHER(bytes(r,'utf-8'), encoder=nacl.encoding.HexEncoder)
        encodedMessage = nacl.encoding.HexEncoder.encode(bytes(r,'utf-8'))
        return digest.decode("utf-8"),encodedMessage.decode("utf-8")
    # def receive(msg=(Configuration,), from_=p):
    def receive(msg=('initial',clientId,requestID,signedRequestStatement,operationCount), from_=c):
        output('---------------------ENTERING Replica:receive:signedRequestStatement-----------------------')
        output("---------------The signed statement with clientID---------------------")
        output(signedRequestStatement)
        orderProof=list()
        resultProof=list()
        temp_verify_key = decodeVerifyKey(clients[clientId][1])
        unSignedRequestStatement = ''
        operation = ''
        if Mode == 'ACTIVE' and not checkRequestIDInHistory(requestID):            
            output("------------clientId------------:",clientId)
            output("-----------------------unsigning signedRequestStatement---------------------------")
            verified = ''
            try:
                verified = verifyTheStatement(temp_verify_key,signedRequestStatement)
            except:
                verified = 'Not verified'
            # output("---------------The unsigned statement received from client---------------------")
            output(verified)
            # output("-----------------------parsing the unSignedRequestStatement---------------------------")            
            operation,key,value = parseTheUnsignedStatement(verified)
            # output("-----------------------Printing Stuff---------------------------")            
            # output(operation)
            # output(key)
            # output(value)
            result = executeOperation(operation,key,value)
            output(result)
            signedOrderStatement,signedResultStatement = createStatements(slot,verified,result)
            output('------------------------Signed Order Statement for union-----------------')
            output(signedOrderStatement)
            # orderProof = unionOrderProofs(orderProof,signedOrderStatement)
            # resultProof = unionResultProofs(resultProof,signedResultStatement)
            orderProof.append(signedOrderStatement)
            resultProof.append(signedResultStatement)
            shuttle = (orderProof,resultProof)     
            # if operationCount==2:
            #    appendToReplicaHistory(slot,verified,orderProof,requestID)    
            appendToReplicaHistory(slot,verified,orderProof,requestID)
            slot+=1
            output(shuttle)
            output(data)
            output("---------------sending shuttle to next replica-------------")
            send((clientId,requestID,shuttle,'initial','nonhead',operationCount), to=replicas[i+1][0])
            output("----------------- I ended ----------------------")


        elif checkRequestIDInHistory(requestID):
            output('------------------------------REDUNDANT REQUEST-------------------')
        else:
            output('Replica is not active')
        
    #send statement to next replica
        # output("-----------------")
        # output(replicas[i+1])
        

    def receive(msg=(clientId,requestID,shuttle,typeOfRequest,replicaType,operationCount),from_=previousReplica):
        output("---------------The  shuttle from previous replica--------------------")
        #print(rho)
        # output(shuttle)

        if i<noOfReplicas and Mode == 'ACTIVE':            
            tempOrderProof = shuttle[0]
            tempResultProof = shuttle[1]
            output('----------------OUTPUT TOTAL ORDER PROOFS------------')
            output(tempOrderProof)
            #Verify with replica history
            verified = verifyOrderProofs(tempOrderProof)
            resultsVerified = verifyResultProofs(tempResultProof)
            if verified != 'False' or resultsVerified != 'False': 
            #('order',2,get('movie'))
                tempOrderStatement = verified.decode('utf-8').split(';')
                output(tempOrderStatement)
                tempSlot = tempOrderStatement[1]            
                tempSignedStatement = tempOrderStatement[2]
                output(tempSlot)
                output(tempSignedStatement) 
                inHistory = checkSlotInHistory(int(tempSlot),tempSignedStatement)
                output(inHistory)
                holes = checkForHoles(int(slot))
                output(holes)
                if inHistory =='false' and holes == False:              
                    # verifyResultProofs()
                    operation,key,value = parseTheUnsignedStatement(bytes(tempSignedStatement,'utf-8'))
                    result = executeOperation(operation,key,value)
                    output('------------DATA DICTIONARY----------')
                    output('Data',data)
                    tempSignedOrderStatement,tempSignedResultStatement = createStatements(tempSlot,bytes(tempSignedStatement,'utf-8'),result)
                    output('Signed Order Statement',tempSignedOrderStatement)
                    tempOrderProof.append(tempSignedOrderStatement)
                    tempResultProof.append(tempSignedResultStatement)
                    appendToReplicaHistory(slot,verified,tempOrderProof,requestID)
                    shuttle = (tempOrderProof,tempResultProof)
                    if i != noOfReplicas-1:  
                        output(replicas[i+1])
                        send((clientId,requestID,shuttle,'initial','nonhead',operationCount), to=replicas[i+1][0])
                    elif i == noOfReplicas-1:
                        # make and send result shuttle to predecessor
                        resultShuttle = (requestID,result,tempResultProof)
                        # if operationCount==2:
                        #     appendToResultCache(resultShuttle)
                        #     # send(('result',resultShuttle), to=clients[clientId][0])
                        #     send(('result',resultShuttle), to=replicas[i-1][0])
                        # signedResultShuttle = 
                        appendToResultCache(resultShuttle)
                        send(('result',resultShuttle), to=clients[clientId][0])
                        send(('result',resultShuttle), to=replicas[i-1][0])
                    else:
                        output('------------------------JUST CHILL------------------------')
                # else:
                #   output('--------------Misbehavoiur, send reconfig request to olympus--------------')
            # else:
            #   output('--------------Signatures Not Verified, send reconfig request to olympus--------------')
            #       terminate = True
        # else:
        #   print('--------------Replica is inactive------------------')
        #     terminate = True
       
        output('-------------------- I ended -------------------------')

    def receive(msg=('retransmission',clientId,requestID,signedRequestStatement,), from_=c):
        output('---------------------ENTERING Replica:receive:retransmission-----------------------')        
        temp_verify_key = decodeVerifyKey(clients[clientId][1])
        verified = ''
        try:
            verified = verifyTheStatement(temp_verify_key,signedRequestStatement)
        except:
            verified = 'Not verified'

        if verified !='Not Verified':
            if Mode == 'IMMUTABLE':
                send(('errorStatement',), to=clients[clientId][0])
            else:
                resultFound,resultShuttle = getResultFromResultCache(requestID)
                output('-------------Result is----------',resultShuttle)
                if resultFound == 'NoResult':
                    if i!=0:
                        send(('forwardRequest',clientId,requestID,signedRequestStatement,), to=replicas[0][0])
                        if await(some(received((result,resultShuttle,)), has=(int(resultShuttle[0]) == requestID))):
                            # --end
                            output("received result")
                            send(('result',resultShuttle), to=clients[clientId][0])                
                        elif timeout(ReplicaTIMEOUT):
                            output('--------------------- Send Reconfiguration request to Olympus(Non head)--------------------------') 
                    # if i==0:
                    #     if checkRequestIDInHistory(requestID):
                    #         if await(some(received((result,resultShuttle,)), has=(int(resultShuttle[0]) == requestID))):
                    #                 # --end
                    #                 output("received result")
                    #                 send(('result',resultShuttle), to=clients[clientId][0])
                                    
                    #         elif timeout(HeadTIMEOUT):
                    #             output('--------------------- Send Reconfiguration request to Olympus(head)--------------------------')
                                
                    #             continue
                    #     else:
                    #         output('--------------------- Start timer from scratch(head)--------------------------')
                    #         # Start timer? and start form scratch                    
                    #         send(('initial',clientId,requestID,signedRequestStatement,2), to=replicas[0][0])
                    #         if await(some(received((result,resultShuttle,)), has=(int(resultShuttle[0]) == requestID))):
                    #                 # --end
                    #                 output("received result")
                    #                 send(('result',resultShuttle), to=clients[clientId][0])
                                    
                    #         elif timeout(HeadTIMEOUT):
                    #             output('--------------------- Send Reconfiguration request to Olympus(head)--------------------------')
                                
                    #             continue

                        # Handle case for client 0 
                elif resultFound=='Found':
                    output('----------------------------Found Result Sending to client')
                    send(('result',resultShuttle), to=clients[clientId][0])

    def receive(msg=('forwardRequest',clientId,requestID,signedRequestStatement,), from_=p):
        output('---------------------ENTERING Replica:receive:forwardRequest-----------------------')  
        temp_verify_key = decodeVerifyKey(clients[clientId][1])
        verified = ''
        try:
            verified = verifyTheStatement(temp_verify_key,signedRequestStatement)
        except:
            verified = 'Not verified'

        if verified !='Not Verified':            
            resultFound,resultShuttle = getResultFromResultCache(requestID)
            output('-------------Result is----------',resultShuttle)
            if resultFound == 'NoResult':
                if checkRequestIDInHistory(requestID):
                    if await(some(received((result,resultShuttle,)), has=(int(resultShuttle[0]) == requestID))):
                            # --end
                            output("received result")
                            send(('result',resultShuttle), to=clients[clientId][0])
                            
                    elif timeout(HeadTIMEOUT):
                        output('--------------------- Send Reconfiguration request to Olympus(head)--------------------------')
                        
                        continue
                else:
                    output('--------------------- Start timer from scratch(head)--------------------------')
                    # Start timer? and start form scratch                    
                    send(('initial',clientId,requestID,signedRequestStatement,2), to=replicas[0][0])
                    if await(some(received((result,resultShuttle,)), has=(int(resultShuttle[0]) == requestID))):
                            # --end
                            output("received result")
                            send(('result',resultShuttle), to=clients[clientId][0])
                            
                    elif timeout(HeadTIMEOUT):
                        output('--------------------- Send Reconfiguration request to Olympus(head)--------------------------')
                        
                        continue   
            elif resultFound=='Found':
                output('----------------------------Found Result Sending to client-------------------')
                send(('result',resultShuttle), to=clients[clientId][0])
            


    def receive(msg=(result,resultShuttle),from_=nextReplica):
        output('-------------------- Received Result Shuttle from Next Replica -------------------------',level=20)
        output(result)
        resultVerification = verifyResultProofs(resultShuttle[2])
        if resultVerification == 'True':
            appendToResultCache(resultShuttle)
        else:
            output('--------------------- Proof of Misbehaviour---------------',level=40)
        output(resultVerification)
        #Verify Result Proofs
        if i!=0:
            send(('result',resultShuttle), to=replicas[i-1][0])
        #validate the result shuttle

    def assignSlot(s,reqID,o):
        replicaHistory[s] = ('order',reqID,o)
        output("---------------inside assignslot----")
        output(replicaHistory[s])

    def createStatements(s,o,r):
        output("-----------------------createStatements---------------------------")            
        orderStatement = bytes(str('\'order\';'+str(s)+';'+o.decode("utf-8")),'utf8')
        output(orderStatement)
        signedOrderStatement = signTheStatement(replica_signing_key,orderStatement)
        output("-----------------------just heres---------------------------")            
        rDigest,encodedResult = hashResult(r)
        output("-----------------------heredmsks---------------------------")
        resultStatement = bytes('\'result\';'+str(s)+';'+rDigest+';'+encodedResult,'utf8')
        signedResultStatement = signTheStatement(replica_signing_key,resultStatement)
        return signedOrderStatement,signedResultStatement


    def verifyOrderProofs(tempOrderProof):
        output("-----------------------verifyOrderProofs---------------------------")
        #Number of order proofs
        numOfOP = len(tempOrderProof)
        i=0
        verified = ''
        while i < numOfOP:
            temp_verify_key = decodeVerifyKey(replicas[i][1])
            tempSignedOP = tempOrderProof[i]
            try:
                verified = verifyTheStatement(temp_verify_key,tempSignedOP)
            except:
                verified = 'False'
            i+=1
        return verified

    def verifyResultProofs(tempResultProof):
        output("-----------------------verifyResultProofs---------------------------")
        #Number of order proofs
        numOfRP = len(tempResultProof)
        tempi=0
        verified = ''
        while tempi < numOfRP:
            temp_verify_key = decodeVerifyKey(replicas[tempi][1])
            tempSignedRP = tempResultProof[tempi]
            try:
                verified = verifyTheStatement(temp_verify_key,tempSignedRP)
                verified ='True'
            except:
                verified = 'False'          
            tempi+=1
        return verified

    def checkRequestIDInHistory(reqID):
        return reqID in [x for v in replicaHistory.values() for x in v]

    def checkSlotInHistory(slot,operation):
        inHistory = 'false'
        output('----------------checkSlotInHistory---------------------')
        output('slot',slot)
        try:
            op = replicaHistory[slot][0]
            output('op',op)
            if operation ==  op:
                inHistory = 'validOperation'
            elif operation != op:
                inHistory = 'invalidOperation'
        except:
            pass
        return inHistory

    def checkForHoles(slot):
        holes = False
        if slot == 0:
            return holes
        try:
            op = replicaHistory[slot-1]         
        except:
            holes = True
        return holes    

    def unionOrderProofs(orderProof,signedOS):
        output("-----------------------unionOrderProofs---------------------------")
        return orderProof.append(signedOS)

    def unionResultProofs(resultProof,signedRS):
        output("-----------------------unionResultProofs---------------------------")
        return resultProof.append(signedRS)

    def appendToReplicaHistory(s,o,orderProof,reqID):
        replicaHistory[s] = (o.decode('utf-8'),orderProof,reqID)

    def appendToResultCache(resultSh):
        # pass
        resultCache[resultSh[0]] = (resultSh[1],resultSh[2])

    def getResultFromResultCache(requestID):
        try:
            tempResult = resultCache[requestID]
            return 'Found',(requestID,tempResult[0],tempResult[1])
        except KeyError:
            return 'NoResult',None

    '''Functions to handle operation Statements'''
    def parseTheUnsignedStatement(unSignedRequestStatement):
        output("-----------------------parseTheUnsignedStatement---------------------------")
        inp = str(unSignedRequestStatement,'utf-8')[:-1]
        output(inp)
        opKeyVal = inp.split('(')
        operation = opKeyVal[0]
        keyVal = opKeyVal[1].split(',')
        key = keyVal[0][1:-1]
        value=''
        if operation!='get':
            value = keyVal[1][1:-1]
        return  operation,key,value.strip()

    def addToDictionary(key,val):
	    try:
	        print(key)
	        data[key]=val
	        return 'OK'
	    except:
	        return 'Fail'

    def getFrom(key,val):
        try:
            return data[key]
        except:
            return ''

    def appendDictionary(key,val):
        try:
            valueExsist = data[key]
            data[key] = val
            return 'OK'
        except:
            return 'fail'

    def sliceDictionary(key,val):
        try:
            print('key',key)
            print(data)
            value = data[key]
            indices = val.split(':')
            print(value)
            data[key] = value[int(indices[0]):int(indices[1])]
            return 'OK'
        except:
            return 'fail'
    # def addToDictionary(key,val):
    #     output("-----------------------addToDictionary---------------------------")
    #     data[key]=val
    #     return 'OK'
    # def getFrom(key,val):
    #     output("-----------------------getFrom---------------------------")
    #     try:
    #         return data[key]
    #     except:
    #         return ''

    # def appendDictionary(key,val):
    #     output("-----------------------appendDictionary---------------------------")

    #     data[key] = val
    #     return 'OK'

    # def sliceDictionary(key,val):
    #     output("-----------------------sliceDictionary---------------------------")

    #     value = data[key]
    #     data[key] = value[val]
    #     return 'OK'

    def executeOperation(operation,key,val):
        output("-----------------------executeOperation---------------------------")

        function_launch = {
            'put': addToDictionary,
            'get': getFrom,
            'append': appendDictionary,
            'slice': sliceDictionary
        }

        return function_launch[operation](key, val)

    def changeOperation():
    	pass
    def changeResult():
    	return 'OK'
    def dropResultStatement():
    	pass
    	#Remove heads result statement from the result proof
    # def receive(msg=('done',), from_=d):
    #     print("---------------ENTERING olympus:receieve:requestConfiguration---------------------")
    #     print("---------------DONE---------------------")


def main():
    output("---------------ENTERING main---------------------")
    olympus = new(Olympus,args=())
    # configure clock = Lamport
    # self.t = logical_time()
    #client = new(Client,args=(olympus,), at='Client')
    #setup(client, args=(olympus,))
    #start(client)
    # setup(olympus, args=())
    start(olympus)