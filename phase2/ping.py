# -*- generated by 1.0.9 -*-
import da
PatternExpr_364 = da.pat.TuplePattern([da.pat.ConstantPattern('requestConfiguration')])
PatternExpr_369 = da.pat.FreePattern('p')
PatternExpr_884 = da.pat.TuplePattern([da.pat.FreePattern('Configuration')])
PatternExpr_889 = da.pat.FreePattern('p')
PatternExpr_956 = da.pat.TuplePattern([da.pat.FreePattern('result'), da.pat.FreePattern('resultShuttle')])
PatternExpr_1005 = da.pat.TuplePattern([da.pat.FreePattern('result'), da.pat.FreePattern('resultShuttle')])
PatternExpr_1012 = da.pat.FreePattern('tail')
PatternExpr_1470 = da.pat.TuplePattern([da.pat.ConstantPattern('initial'), da.pat.FreePattern('clientId'), da.pat.FreePattern('requestID'), da.pat.FreePattern('signedRequestStatement'), da.pat.FreePattern('operationCount')])
PatternExpr_1483 = da.pat.FreePattern('c')
PatternExpr_1646 = da.pat.TuplePattern([da.pat.FreePattern('clientId'), da.pat.FreePattern('requestID'), da.pat.FreePattern('shuttle'), da.pat.FreePattern('typeOfRequest'), da.pat.FreePattern('replicaType'), da.pat.FreePattern('operationCount')])
PatternExpr_1661 = da.pat.FreePattern('previousReplica')
PatternExpr_1909 = da.pat.TuplePattern([da.pat.ConstantPattern('retransmission'), da.pat.FreePattern('clientId'), da.pat.FreePattern('requestID'), da.pat.FreePattern('signedRequestStatement')])
PatternExpr_1920 = da.pat.FreePattern('c')
PatternExpr_2004 = da.pat.TuplePattern([da.pat.FreePattern('result'), da.pat.FreePattern('resultShuttle')])
PatternExpr_2062 = da.pat.TuplePattern([da.pat.ConstantPattern('forwardRequest'), da.pat.FreePattern('clientId'), da.pat.FreePattern('requestID'), da.pat.FreePattern('signedRequestStatement')])
PatternExpr_2073 = da.pat.FreePattern('p')
PatternExpr_2131 = da.pat.TuplePattern([da.pat.FreePattern('result'), da.pat.FreePattern('resultShuttle')])
PatternExpr_2248 = da.pat.TuplePattern([da.pat.FreePattern('result'), da.pat.FreePattern('resultShuttle')])
PatternExpr_2255 = da.pat.FreePattern('nextReplica')
_config_object = {}
import sys
import nacl.utils
from random import *
import random
import nacl.encoding
import nacl.hash
from nacl.bindings.utils import sodium_memcmp
import nacl.signing
import logging

def readConfigFile():
    config = dict()
    with open('config.csv', 'r') as f:
        for line in f:
            if (not (line[0] == '#')):
                (key, sep, val) = line.partition('=')
                if (not (len(sep) == 0)):
                    val = val.strip()
                    config[key.strip()] = (int(val) if str.isdecimal(val) else val)
    return config

def signTheStatement(signing_key, message):
    return signing_key.sign(message)
    self.output('-------------Signed the message---------------------------')

def decodeVerifyKey(verify_key_hex):
    return nacl.signing.VerifyKey(verify_key_hex, encoder=nacl.encoding.HexEncoder)

def verifyTheStatement(verify_key, signed):
    return verify_key.verify(signed)

class Olympus(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_OlympusReceivedEvent_0', PatternExpr_364, sources=[PatternExpr_369], destinations=None, timestamps=None, record_history=None, handlers=[self._Olympus_handler_363])])

    def setup(self, **rest_2906):
        super().setup(**rest_2906)
        self.output('---------------ENTERING Olymus:setup ---------------------', level=20)
        self.output(self._id)
        self._state.terminate = False
        self._state.client_signing_keys = dict()
        self._state.client_verify_keys_hex = dict()
        self._state.replica_signing_keys = dict()
        self._state.replica_verify_keys_hex = dict()
        self.initialSetup()

    def run(self):
        super()._label('_st_label_357', block=False)
        _st_label_357 = 0
        while (_st_label_357 == 0):
            _st_label_357 += 1
            if self._state.terminate:
                _st_label_357 += 1
            else:
                super()._label('_st_label_357', block=True)
                _st_label_357 -= 1
        self.output('terminating')

    def readGlobalConfigFile(self):
        self.output('---------------ENTERING Olymus:readGlobalConfigFile ---------------------')
        globalConfiggg = readConfigFile()
        self.output('----EXIT-----')

    def initialSetup(self):
        self.output('---------------ENTERING Olymus:initialSetup ---------------------')
        self._state.globalConfig = readConfigFile()
        noOfClients = self._state.globalConfig['num_client']
        noOfReplicas = ((2 * self._state.globalConfig['t']) + 1)
        (self._state.client_signing_keys, self._state.client_verify_keys_hex) = self.createKeys(noOfClients)
        self._state.clients = self.createClientProcesses(self._state.client_signing_keys)
        (self._state.replica_signing_keys, self._state.replica_verify_keys_hex) = self.createKeys(noOfReplicas)
        self._state.replicas = self.createReplicaProcesses(self._state.replica_signing_keys, self._state.clients, self._state.replica_verify_keys_hex)

    def createKeys(self, number):
        self.output('---------------ENTERING Olymus:createKeys ---------------------', level=40)
        signing_keys = dict()
        verify_keys_hex = dict()
        for i in range(number):
            signing_key = nacl.signing.SigningKey.generate()
            verify_key = signing_key.verify_key
            verify_key_hex = verify_key.encode(encoder=nacl.encoding.HexEncoder)
            signing_keys[i] = signing_key
            verify_keys_hex[i] = verify_key_hex
        return (signing_keys, verify_keys_hex)

    def createClientProcesses(self, client_signing_keys):
        tempClients = []
        self.output('---------------ENTERING CLIENT CREATE PROCESS---------------------')
        noOfClients = self._state.globalConfig['num_client']
        hosts = self._state.globalConfig['hosts'].split(';')
        client_hosts = self._state.globalConfig['client_hosts'].split(';')
        for i in range(noOfClients):
            processAtNode = ('Client' + str(i))
            client = self.new(Client, at=processAtNode)
            self._setup(client, (self._id, i, client_signing_keys[i]))
            self._start(client)
            tempClients.insert(i, (client, self._state.client_verify_keys_hex[i]))
        return tempClients

    def createReplicaProcesses(self, replica_signing_keys, clients, replica_verify_keys_hex):
        self.output('---------------ENTERING REPLICA CREATE PROCESS---------------------')
        tempReplicas = dict()
        noOfReplicas = ((2 * self._state.globalConfig['t']) + 1)
        hosts = self._state.globalConfig['hosts'].split(';')
        replica_hosts = self._state.globalConfig['replica_hosts'].split(';')
        for i in range(noOfReplicas):
            processAtNode = ('Replica' + str(i))
            replica = self.new(Replica, at=processAtNode)
            tempReplicas[i] = (replica, replica_verify_keys_hex[i])
        for i in range(noOfReplicas):
            self._setup(tempReplicas[i][0], (self._id, i, 'ACTIVE', replica_signing_keys[i], clients, tempReplicas))
            self._start(tempReplicas[i][0])
        return tempReplicas

    def createConfiguration(self):
        pass

    def setupProcesses(self):
        self.output('---------------ENTERING setupProcesses ---------------------')
        for i in range(noOfClients):
            self._setup(client[i], args=(self._id,))

    def startProcesses(self):
        self.output('---------------ENTERING startProcesses ---------------------')
        for i in range(noOfClients):
            self._start(client[i])

    def _Olympus_handler_363(self, p):
        self.output('---------------ENTERING olympus:receieve:requestConfiguration---------------------')
        self.output(p)
        Configuration = self._state.replicas
        self.send((Configuration,), to=p)
    _Olympus_handler_363._labels = None
    _Olympus_handler_363._notlabels = None

class Client(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ClientReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_0', PatternExpr_884, sources=[PatternExpr_889], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_883]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_1', PatternExpr_956, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ClientReceivedEvent_2', PatternExpr_1005, sources=[PatternExpr_1012], destinations=None, timestamps=None, record_history=None, handlers=[self._Client_handler_1004])])

    def setup(self, p, clientID, client_signing_key, **rest_2906):
        super().setup(p=p, clientID=clientID, client_signing_key=client_signing_key, **rest_2906)
        self._state.p = p
        self._state.clientID = clientID
        self._state.client_signing_key = client_signing_key
        self._state.terminate = False
        self._state.replicas = dict()
        self._state.TIMEOUT = 0
        self._state.globalConfig = dict()
        self._state.noOfReplicas = 0

    def run(self):
        self.output('---------------ENTERING client:run---------------------')
        self.send(('requestConfiguration',), to=self._state.p)
        self._state.globalConfig = readConfigFile()
        self._state.TIMEOUT = self._state.globalConfig['client_timeout']
        self._state.noOfReplicas = ((2 * self._state.globalConfig['t']) + 1)
        super()._label('_st_label_804', block=False)
        _st_label_804 = 0
        while (_st_label_804 == 0):
            _st_label_804 += 1
            if self._state.terminate:
                _st_label_804 += 1
            else:
                super()._label('_st_label_804', block=True)
                _st_label_804 -= 1

    def hashResult(self, r):
        self.output('---------------ENTERING hashResult ---------------------')
        HASHER = nacl.hash.sha256
        digest = HASHER(bytes(r, 'utf-8'), encoder=nacl.encoding.HexEncoder)
        encodedMessage = nacl.encoding.HexEncoder.encode(bytes(r, 'utf-8'))
        return (digest.decode('utf-8'), encodedMessage.decode('utf-8'))

    def checkHashResult(self, digest, rDigest):
        self.output('---------------ENTERING checkHashResult ---------------------')
        bDigest = bytes(digest, 'utf-8')
        brDigest = bytes(rDigest, 'utf-8')
        if sodium_memcmp(bDigest, brDigest):
            return True
        return False

    def getOperations(self):
        cWorkLoad = self._state.globalConfig[(('workload[' + str(self._state.clientID)) + ']')]
        if ('pseudorandom' in cWorkLoad):
            seedAndNoOfRequests = cWorkLoad[:(- 1)].split('(')[1].split(',')
            return self.generatePseudoRandomRequests(int(seedAndNoOfRequests[0]), int(seedAndNoOfRequests[1]))
        else:
            return cWorkLoad.split(';')

    def sendRequest(self, requestID, operation, receiver, typeOfRequest):
        self.output(operation)
        requestStatement = bytes(str(operation.strip()), 'utf8')
        self.output(requestStatement)
        signedRequestStatement = signTheStatement(self._state.client_signing_key, requestStatement)
        if (typeOfRequest == 'initial'):
            self.send((typeOfRequest, self._state.clientID, requestID, signedRequestStatement, 1), to=receiver[0])
        elif (typeOfRequest == 'retransmission'):
            for replicaNo in range(self._state.noOfReplicas):
                self.send((typeOfRequest, self._state.clientID, requestID, signedRequestStatement), to=receiver[replicaNo][0])
        self.output(signedRequestStatement)

    def generatePseudoRandomRequests(self, rSeed, noOfRequests):
        listofRequest = ["put('movie','star')", "append('movie',' wars')", "get('movie')", "put('jedi,'luke skywalker)", "slice('jedi','0:4')", "get('jedi')"]
        random.seed(rSeed)
        requests = random.sample(listofRequest, k=noOfRequests)
        return requests

    def returnRandomNumber(self):
        return randint(1, 10000)

    def verifyResultProofs(self, tempResultProof, rDigest):
        self.output('-----------------------verifyResultProofs---------------------------')
        numOfRP = len(tempResultProof)
        i = 0
        verified = ''
        while (i < numOfRP):
            temp_verify_key = decodeVerifyKey(self._state.replicas[i][1])
            tempSignedRP = tempResultProof[i]
            try:
                verified = verifyTheStatement(temp_verify_key, tempSignedRP)
                self.output(verified)
                strVerified = verified.decode('utf8')
                verifiedTuple = strVerified.split(';')
                self.output('--------------------verifying Digest', verifiedTuple[2])
                self.output('--------------------originalDigest', rDigest)
                if self.checkHashResult(verifiedTuple[2], rDigest):
                    verified = 'True'
                else:
                    verified = 'False'
            except:
                verified = 'Falsela'
            i += 1
        return verified

    def _Client_handler_883(self, Configuration, p):
        self.output('---------------ENTERING client:receive:Configuration---------------------')
        self._state.replicas = Configuration
        self.output(len(Configuration))
        for x in range(len(Configuration)):
            print('Replica:', Configuration[x])
        operations = self.getOperations()
        self.output(operations)
        for i in range(len(operations)):
            self.output('------SENDING REQUESTS LOOP----------------')
            requestID = self.returnRandomNumber()
            self.output('requestID: ', requestID)
            self.output('------SENDING REQUESTS LOOP----------------')
            self.sendRequest(requestID, operations[i], Configuration[0], 'initial')
            super()._label('_st_label_953', block=False)
            result = resultShuttle = None

            def ExistentialOpExpr_954():
                nonlocal result, resultShuttle
                for (_, _, (result, resultShuttle)) in self._ClientReceivedEvent_1:
                    if (int(resultShuttle[0]) == requestID):
                        return True
                return False
            _st_label_953 = 0
            self._timer_start()
            while (_st_label_953 == 0):
                _st_label_953 += 1
                if ExistentialOpExpr_954():
                    self.output('received result')
                    continue
                    _st_label_953 += 1
                elif self._timer_expired:
                    self.output('Send Retransmission Request.')
                    self.sendRequest(requestID, operations[i], Configuration, 'retransmission')
                    continue
                    _st_label_953 += 1
                else:
                    super()._label('_st_label_953', block=True, timeout=self._state.TIMEOUT)
                    _st_label_953 -= 1
            else:
                if (_st_label_953 != 2):
                    continue
            if (_st_label_953 != 2):
                break
        self.send(('Received Configuration',), to=p)
    _Client_handler_883._labels = None
    _Client_handler_883._notlabels = None

    def _Client_handler_1004(self, result, resultShuttle, tail):
        self.output('-------------------- Received Result Shuttle-----------------------')
        receivedResult = resultShuttle[1]
        (rDigest, rEncodedMessage) = self.hashResult(receivedResult)
        resultVerified = self.verifyResultProofs(resultShuttle[2], rDigest)
        self.output(resultVerified)
        self.output(resultShuttle)
    _Client_handler_1004._labels = None
    _Client_handler_1004._notlabels = None

class Replica(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._ReplicaReceivedEvent_3 = []
        self._ReplicaReceivedEvent_5 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_0', PatternExpr_1470, sources=[PatternExpr_1483], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1469]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_1', PatternExpr_1646, sources=[PatternExpr_1661], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1645]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_2', PatternExpr_1909, sources=[PatternExpr_1920], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_1908]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_3', PatternExpr_2004, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_4', PatternExpr_2062, sources=[PatternExpr_2073], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2061]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_5', PatternExpr_2131, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ReplicaReceivedEvent_6', PatternExpr_2248, sources=[PatternExpr_2255], destinations=None, timestamps=None, record_history=None, handlers=[self._Replica_handler_2247])])

    def setup(self, p, i, Mode, replica_signing_key, clients, replicas, **rest_2906):
        super().setup(p=p, i=i, Mode=Mode, replica_signing_key=replica_signing_key, clients=clients, replicas=replicas, **rest_2906)
        self._state.p = p
        self._state.i = i
        self._state.Mode = Mode
        self._state.replica_signing_key = replica_signing_key
        self._state.clients = clients
        self._state.replicas = replicas
        self._state.terminate = False
        self._state.data = dict()
        self._state.replicaHistory = dict()
        self._state.resultCache = dict()
        self._state.slot = 0
        self._state.globalConfig = dict()
        self._state.noOfReplicas = 0
        self._state.ReplicaTIMEOUT = 0
        self._state.HeadTIMEOUT = 0

    def run(self):
        self.output('---------------------ENTERING Replica:run-----------------------')
        self.output(self._state.p)
        self.output('------------------printing replicas with their public keys------------')
        self._state.globalConfig = readConfigFile()
        self._state.noOfReplicas = ((2 * self._state.globalConfig['t']) + 1)
        self._state.ReplicaTIMEOUT = self._state.globalConfig['nonhead_timeout']
        self._state.HeadTIMEOUT = self._state.globalConfig['head_timeout']
        super()._label('_st_label_1417', block=False)
        _st_label_1417 = 0
        while (_st_label_1417 == 0):
            _st_label_1417 += 1
            if self._state.terminate:
                _st_label_1417 += 1
            else:
                super()._label('_st_label_1417', block=True)
                _st_label_1417 -= 1
        self.output('--------------------Something------------------------')

    def hashResult(self, r):
        self.output('---------------ENTERING hashResult ---------------------')
        HASHER = nacl.hash.sha256
        digest = HASHER(bytes(r, 'utf-8'), encoder=nacl.encoding.HexEncoder)
        encodedMessage = nacl.encoding.HexEncoder.encode(bytes(r, 'utf-8'))
        return (digest.decode('utf-8'), encodedMessage.decode('utf-8'))

    def assignSlot(self, s, reqID, o):
        self._state.replicaHistory[s] = ('order', reqID, o)
        self.output('---------------inside assignslot----')
        self.output(self._state.replicaHistory[s])

    def createStatements(self, s, o, r):
        self.output('-----------------------createStatements---------------------------')
        orderStatement = bytes(str(((("'order';" + str(s)) + ';') + o.decode('utf-8'))), 'utf8')
        self.output(orderStatement)
        signedOrderStatement = signTheStatement(self._state.replica_signing_key, orderStatement)
        self.output('-----------------------just heres---------------------------')
        (rDigest, encodedResult) = self.hashResult(r)
        self.output('-----------------------heredmsks---------------------------')
        resultStatement = bytes(((((("'result';" + str(s)) + ';') + rDigest) + ';') + encodedResult), 'utf8')
        signedResultStatement = signTheStatement(self._state.replica_signing_key, resultStatement)
        return (signedOrderStatement, signedResultStatement)

    def verifyOrderProofs(self, tempOrderProof):
        self.output('-----------------------verifyOrderProofs---------------------------')
        numOfOP = len(tempOrderProof)
        self._state.i = 0
        verified = ''
        while (self._state.i < numOfOP):
            temp_verify_key = decodeVerifyKey(self._state.replicas[self._state.i][1])
            tempSignedOP = tempOrderProof[self._state.i]
            try:
                verified = verifyTheStatement(temp_verify_key, tempSignedOP)
            except:
                verified = 'False'
            self._state.i += 1
        return verified

    def verifyResultProofs(self, tempResultProof):
        self.output('-----------------------verifyResultProofs---------------------------')
        numOfRP = len(tempResultProof)
        tempi = 0
        verified = ''
        while (tempi < numOfRP):
            temp_verify_key = decodeVerifyKey(self._state.replicas[tempi][1])
            tempSignedRP = tempResultProof[tempi]
            try:
                verified = verifyTheStatement(temp_verify_key, tempSignedRP)
                verified = 'True'
            except:
                verified = 'False'
            tempi += 1
        return verified

    def checkRequestIDInHistory(self, reqID):
        return (reqID in [x for v in self._state.replicaHistory.values() for x in v])

    def checkSlotInHistory(self, slot, operation):
        inHistory = 'false'
        self.output('----------------checkSlotInHistory---------------------')
        self.output('slot', slot)
        try:
            op = self._state.replicaHistory[slot][0]
            self.output('op', op)
            if (operation == op):
                inHistory = 'validOperation'
            elif (not (operation == op)):
                inHistory = 'invalidOperation'
        except:
            pass
        return inHistory

    def checkForHoles(self, slot):
        holes = False
        if (slot == 0):
            return holes
        try:
            op = self._state.replicaHistory[(slot - 1)]
        except:
            holes = True
        return holes

    def unionOrderProofs(self, orderProof, signedOS):
        self.output('-----------------------unionOrderProofs---------------------------')
        return orderProof.append(signedOS)

    def unionResultProofs(self, resultProof, signedRS):
        self.output('-----------------------unionResultProofs---------------------------')
        return resultProof.append(signedRS)

    def appendToReplicaHistory(self, s, o, orderProof, reqID):
        self._state.replicaHistory[s] = (o.decode('utf-8'), orderProof, reqID)

    def appendToResultCache(self, resultSh):
        self._state.resultCache[resultSh[0]] = (resultSh[1], resultSh[2])

    def getResultFromResultCache(self, requestID):
        try:
            tempResult = self._state.resultCache[requestID]
            return ('Found', (requestID, tempResult[0], tempResult[1]))
        except KeyError:
            return ('NoResult', None)

    def parseTheUnsignedStatement(self, unSignedRequestStatement):
        self.output('-----------------------parseTheUnsignedStatement---------------------------')
        inp = str(unSignedRequestStatement, 'utf-8')[:(- 1)]
        self.output(inp)
        opKeyVal = inp.split('(')
        operation = opKeyVal[0]
        keyVal = opKeyVal[1].split(',')
        key = keyVal[0][1:(- 1)]
        value = ''
        if (not (operation == 'get')):
            value = keyVal[1][1:(- 1)]
        return (operation, key, value.strip())

    def addToDictionary(self, key, val):
        try:
            print(key)
            self._state.data[key] = val
            return 'OK'
        except:
            return 'Fail'

    def getFrom(self, key, val):
        try:
            return self._state.data[key]
        except:
            return ''

    def appendDictionary(self, key, val):
        try:
            valueExsist = self._state.data[key]
            self._state.data[key] = val
            return 'OK'
        except:
            return 'fail'

    def sliceDictionary(self, key, val):
        try:
            print('key', key)
            print(self._state.data)
            value = self._state.data[key]
            indices = val.split(':')
            print(value)
            self._state.data[key] = value[int(indices[0]):int(indices[1])]
            return 'OK'
        except:
            return 'fail'

    def executeOperation(self, operation, key, val):
        self.output('-----------------------executeOperation---------------------------')
        function_launch = {'put': self.addToDictionary, 'get': self.getFrom, 'append': self.appendDictionary, 'slice': self.sliceDictionary}
        return function_launch[operation](key, val)

    def _Replica_handler_1469(self, clientId, requestID, signedRequestStatement, operationCount, c):
        self.output('---------------------ENTERING Replica:receive:signedRequestStatement-----------------------')
        self.output('---------------The signed statement with clientID---------------------')
        self.output(signedRequestStatement)
        orderProof = list()
        resultProof = list()
        temp_verify_key = decodeVerifyKey(self._state.clients[clientId][1])
        unSignedRequestStatement = ''
        operation = ''
        if ((self._state.Mode == 'ACTIVE') and (not self.checkRequestIDInHistory(requestID))):
            self.output('------------clientId------------:', clientId)
            self.output('-----------------------unsigning signedRequestStatement---------------------------')
            verified = ''
            try:
                verified = verifyTheStatement(temp_verify_key, signedRequestStatement)
            except:
                verified = 'Not verified'
            self.output(verified)
            (operation, key, value) = self.parseTheUnsignedStatement(verified)
            result = self.executeOperation(operation, key, value)
            self.output(result)
            (signedOrderStatement, signedResultStatement) = self.createStatements(self._state.slot, verified, result)
            self.output('------------------------Signed Order Statement for union-----------------')
            self.output(signedOrderStatement)
            orderProof.append(signedOrderStatement)
            resultProof.append(signedResultStatement)
            shuttle = (orderProof, resultProof)
            self.appendToReplicaHistory(self._state.slot, verified, orderProof, requestID)
            self._state.slot += 1
            self.output(shuttle)
            self.output(self._state.data)
            self.output('---------------sending shuttle to next replica-------------')
            self.send((clientId, requestID, shuttle, 'initial', 'nonhead', operationCount), to=self._state.replicas[(self._state.i + 1)][0])
            self.output('----------------- I ended ----------------------')
        elif self.checkRequestIDInHistory(requestID):
            self.output('------------------------------REDUNDANT REQUEST-------------------')
        else:
            self.output('Replica is not active')
    _Replica_handler_1469._labels = None
    _Replica_handler_1469._notlabels = None

    def _Replica_handler_1645(self, clientId, requestID, shuttle, typeOfRequest, replicaType, operationCount, previousReplica):
        self.output('---------------The  shuttle from previous replica--------------------')
        if ((self._state.i < self._state.noOfReplicas) and (self._state.Mode == 'ACTIVE')):
            tempOrderProof = shuttle[0]
            tempResultProof = shuttle[1]
            self.output('----------------OUTPUT TOTAL ORDER PROOFS------------')
            self.output(tempOrderProof)
            verified = self.verifyOrderProofs(tempOrderProof)
            resultsVerified = self.verifyResultProofs(tempResultProof)
            if ((not (verified == 'False')) or (not (resultsVerified == 'False'))):
                tempOrderStatement = verified.decode('utf-8').split(';')
                self.output(tempOrderStatement)
                tempSlot = tempOrderStatement[1]
                tempSignedStatement = tempOrderStatement[2]
                self.output(tempSlot)
                self.output(tempSignedStatement)
                inHistory = self.checkSlotInHistory(int(tempSlot), tempSignedStatement)
                self.output(inHistory)
                holes = self.checkForHoles(int(self._state.slot))
                self.output(holes)
                if ((inHistory == 'false') and (holes == False)):
                    (operation, key, value) = self.parseTheUnsignedStatement(bytes(tempSignedStatement, 'utf-8'))
                    result = self.executeOperation(operation, key, value)
                    self.output('------------DATA DICTIONARY----------')
                    self.output('Data', self._state.data)
                    (tempSignedOrderStatement, tempSignedResultStatement) = self.createStatements(tempSlot, bytes(tempSignedStatement, 'utf-8'), result)
                    self.output('Signed Order Statement', tempSignedOrderStatement)
                    tempOrderProof.append(tempSignedOrderStatement)
                    tempResultProof.append(tempSignedResultStatement)
                    self.appendToReplicaHistory(self._state.slot, verified, tempOrderProof, requestID)
                    shuttle = (tempOrderProof, tempResultProof)
                    if (not (self._state.i == (self._state.noOfReplicas - 1))):
                        self.output(self._state.replicas[(self._state.i + 1)])
                        self.send((clientId, requestID, shuttle, 'initial', 'nonhead', operationCount), to=self._state.replicas[(self._state.i + 1)][0])
                    elif (self._state.i == (self._state.noOfReplicas - 1)):
                        resultShuttle = (requestID, result, tempResultProof)
                        self.appendToResultCache(resultShuttle)
                        self.send(('result', resultShuttle), to=self._state.clients[clientId][0])
                        self.send(('result', resultShuttle), to=self._state.replicas[(self._state.i - 1)][0])
                    else:
                        self.output('------------------------JUST CHILL------------------------')
        self.output('-------------------- I ended -------------------------')
    _Replica_handler_1645._labels = None
    _Replica_handler_1645._notlabels = None

    def _Replica_handler_1908(self, clientId, requestID, signedRequestStatement, c):
        self.output('---------------------ENTERING Replica:receive:retransmission-----------------------')
        temp_verify_key = decodeVerifyKey(self._state.clients[clientId][1])
        verified = ''
        try:
            verified = verifyTheStatement(temp_verify_key, signedRequestStatement)
        except:
            verified = 'Not verified'
        if (not (verified == 'Not Verified')):
            if (self._state.Mode == 'IMMUTABLE'):
                self.send(('errorStatement',), to=self._state.clients[clientId][0])
            else:
                (resultFound, resultShuttle) = self.getResultFromResultCache(requestID)
                self.output('-------------Result is----------', resultShuttle)
                if (resultFound == 'NoResult'):
                    if (not (self._state.i == 0)):
                        self.send(('forwardRequest', clientId, requestID, signedRequestStatement), to=self._state.replicas[0][0])
                        super()._label('_st_label_2001', block=False)
                        result = resultShuttle = None

                        def ExistentialOpExpr_2002():
                            nonlocal result, resultShuttle
                            for (_, _, (result, resultShuttle)) in self._ReplicaReceivedEvent_3:
                                if (int(resultShuttle[0]) == requestID):
                                    return True
                            return False
                        _st_label_2001 = 0
                        self._timer_start()
                        while (_st_label_2001 == 0):
                            _st_label_2001 += 1
                            if ExistentialOpExpr_2002():
                                self.output('received result')
                                self.send(('result', resultShuttle), to=self._state.clients[clientId][0])
                                _st_label_2001 += 1
                            elif self._timer_expired:
                                self.output('--------------------- Send Reconfiguration request to Olympus(Non head)--------------------------')
                                _st_label_2001 += 1
                            else:
                                super()._label('_st_label_2001', block=True, timeout=self._state.ReplicaTIMEOUT)
                                _st_label_2001 -= 1
                elif (resultFound == 'Found'):
                    self.output('----------------------------Found Result Sending to client')
                    self.send(('result', resultShuttle), to=self._state.clients[clientId][0])
    _Replica_handler_1908._labels = None
    _Replica_handler_1908._notlabels = None

    def _Replica_handler_2061(self, clientId, requestID, signedRequestStatement, p):
        self.output('---------------------ENTERING Replica:receive:forwardRequest-----------------------')
        temp_verify_key = decodeVerifyKey(self._state.clients[clientId][1])
        verified = ''
        try:
            verified = verifyTheStatement(temp_verify_key, signedRequestStatement)
        except:
            verified = 'Not verified'
        if (not (verified == 'Not Verified')):
            (resultFound, resultShuttle) = self.getResultFromResultCache(requestID)
            self.output('-------------Result is----------', resultShuttle)
            if (resultFound == 'NoResult'):
                if self.checkRequestIDInHistory(requestID):
                    super()._label('_st_label_2128', block=False)
                    result = resultShuttle = None

                    def ExistentialOpExpr_2129():
                        nonlocal result, resultShuttle
                        for (_, _, (result, resultShuttle)) in self._ReplicaReceivedEvent_5:
                            if (int(resultShuttle[0]) == requestID):
                                return True
                        return False
                    _st_label_2128 = 0
                    self._timer_start()
                    while (_st_label_2128 == 0):
                        _st_label_2128 += 1
                        if ExistentialOpExpr_2129():
                            self.output('received result')
                            self.send(('result', resultShuttle), to=self._state.clients[clientId][0])
                            _st_label_2128 += 1
                        elif self._timer_expired:
                            self.output('--------------------- Send Reconfiguration request to Olympus(head)--------------------------')
                            continue
                            _st_label_2128 += 1
                        else:
                            super()._label('_st_label_2128', block=True, timeout=self._state.HeadTIMEOUT)
                            _st_label_2128 -= 1
                else:
                    self.output('--------------------- Start timer from scratch(head)--------------------------')
                    self.send(('initial', clientId, requestID, signedRequestStatement, 2), to=self._state.replicas[0][0])
                    super()._label('_st_label_2187', block=False)
                    result = resultShuttle = None

                    def ExistentialOpExpr_2188():
                        nonlocal result, resultShuttle
                        for (_, _, (result, resultShuttle)) in self._ReplicaReceivedEvent_5:
                            if (int(resultShuttle[0]) == requestID):
                                return True
                        return False
                    _st_label_2187 = 0
                    self._timer_start()
                    while (_st_label_2187 == 0):
                        _st_label_2187 += 1
                        if ExistentialOpExpr_2188():
                            self.output('received result')
                            self.send(('result', resultShuttle), to=self._state.clients[clientId][0])
                            _st_label_2187 += 1
                        elif self._timer_expired:
                            self.output('--------------------- Send Reconfiguration request to Olympus(head)--------------------------')
                            continue
                            _st_label_2187 += 1
                        else:
                            super()._label('_st_label_2187', block=True, timeout=self._state.HeadTIMEOUT)
                            _st_label_2187 -= 1
            elif (resultFound == 'Found'):
                self.output('----------------------------Found Result Sending to client-------------------')
                self.send(('result', resultShuttle), to=self._state.clients[clientId][0])
    _Replica_handler_2061._labels = None
    _Replica_handler_2061._notlabels = None

    def _Replica_handler_2247(self, result, resultShuttle, nextReplica):
        self.output('-------------------- Received Result Shuttle from Next Replica -------------------------', level=20)
        self.output(result)
        resultVerification = self.verifyResultProofs(resultShuttle[2])
        if (resultVerification == 'True'):
            self.appendToResultCache(resultShuttle)
        else:
            self.output('--------------------- Proof of Misbehaviour---------------', level=40)
        self.output(resultVerification)
        if (not (self._state.i == 0)):
            self.send(('result', resultShuttle), to=self._state.replicas[(self._state.i - 1)][0])
    _Replica_handler_2247._labels = None
    _Replica_handler_2247._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def run(self):
        self.output('---------------ENTERING main---------------------')
        olympus = self.new(Olympus, args=())
        self._start(olympus)
